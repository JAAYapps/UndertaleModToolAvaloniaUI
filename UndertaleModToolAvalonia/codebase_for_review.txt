====================================================================
FILE: ./App.axaml
====================================================================

<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
			 xmlns:sty="using:FluentAvalonia.Styling"
             x:Class="UndertaleModToolAvalonia.App"
             xmlns:local="using:UndertaleModToolAvalonia"
             RequestedThemeVariant="Default">
             <!-- "Default" ThemeVariant follows system theme variant. "Dark" or "Light" are other available options. -->

    <Application.DataTemplates>
        <local:ViewLocator/>
    </Application.DataTemplates>
  
    <Application.Styles>
        <sty:FluentAvaloniaTheme PreferSystemTheme="True" PreferUserAccentColor="True" />
        <StyleInclude Source="/Styles/MenuIcons.axaml"/>
		<StyleInclude Source="/Styles/SideBar.axaml" />
    </Application.Styles>
</Application>

====================================================================
FILE: ./App.axaml.cs
====================================================================

using Avalonia;
using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Core.Plugins;
using Avalonia.Markup.Xaml;
using Microsoft.Extensions.DependencyInjection;
using System;
using UndertaleModToolAvalonia.Services.FileService;
using UndertaleModToolAvalonia.Services.PlayerService;
using UndertaleModToolAvalonia.Utility;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;
using UndertaleModToolAvalonia.Views.EditorViews;
using MainWindow = UndertaleModToolAvalonia.Views.MainWindow;
using MainWindowViewModel = UndertaleModToolAvalonia.ViewModels.MainWindowViewModel;

namespace UndertaleModToolAvalonia;

public partial class App : Application
{
    /// <summary>
    /// Gets the service provider for dependency injection.
    /// </summary>
    public IServiceProvider Services { get; private set; } = null!;

    public static new App? Current => Application.Current as App;

    public override void Initialize()
    {
        AvaloniaXamlLoader.Load(this);
        Services = ConfigureServices();
    }
    
    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            if (Program.completeFail)
            {
                _ = Current?.ShowError(Program.failMessage);
                return;
            }
            // Line below is needed to remove Avalonia data validation.
            // Without this line you will get duplicate validations from both Avalonia and CT
            BindingPlugins.DataValidators.RemoveAt(0);
            // Window main = WindowLoader.createWindow(null,
            //     typeof(EditorView), typeof(EditorViewModel), true, false);

            

            try
            {
                desktop.MainWindow = desktop.MainWindow = Services.GetRequiredService<MainWindow>();
                // Window main = WindowLoader.createWindow(null, typeof(MainWindow), typeof(MainWindowViewModel), true, false);
                // desktop.MainWindow = main;
            }
            catch (Exception e)
            {
                // Avalonia is a bit weird when I only want to display a messagebox only to display a fatal error.
                // I had to create a new Window and hide it just for the framework to display the message.
                Console.WriteLine(e);
/*                if (desktop.MainWindow != null)
                    desktop.MainWindow.Close();
                Window main = new Window();
                if (main != null)
                {
                    main.Hide();
                    main.Loaded += (_, __) =>
                    {
                        main.Close();
                    };
                }*/
                _ = Current?.ShowError(e.ToString());
                Program.completeFail = true;
            }
        }
        
        base.OnFrameworkInitializationCompleted();
    }

    /// <summary>
    /// Configures the services for the application.
    /// </summary>
    private static IServiceProvider ConfigureServices()
    {
        var services = new ServiceCollection();

        services.AddSingleton<IPlayer, Player>();
        services.AddSingleton<IFileService, FileService>();
        services.AddTransient<LoaderDialogViewModel>();
        services.AddTransient<MainWindowViewModel>();

        services.AddTransient<LoaderDialogView>(provider => new LoaderDialogView
        {
            DataContext = provider.GetRequiredService<LoaderDialogViewModel>()
        });

        // Register Views (Windows)
        services.AddTransient<MainWindow>(provider => new MainWindow
        {
            DataContext = provider.GetRequiredService<MainWindowViewModel>()
        });

        return services.BuildServiceProvider();
    }
}

====================================================================
FILE: ./AppConstants.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UndertaleModLib;

namespace UndertaleModToolAvalonia
{
    public static class AppConstants
    {
        private static UndertaleData? data = null;

        public static UndertaleData? Data { get => data; set => data = value; }

        public static string? FilePath { get; set; }
        
        public static string? ScriptPath { get; set; } // For the scripting interface specifically
        
        public static string LOCATION { get => AppDomain.CurrentDomain.BaseDirectory; }
    }
}


====================================================================
FILE: ./codebase_for_review.txt
====================================================================



====================================================================
FILE: ./Converters/BooleanToVisibilityConverter.cs
====================================================================

﻿using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    public sealed class BooleanToVisibilityConverter : IValueConverter
    {
        public bool trueValue { get; set; }
        public bool falseValue { get; set; }
        
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is bool boolean && boolean) ? trueValue : falseValue;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/ByteArrayConverter.cs
====================================================================

﻿using System;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    // [ValueConversion(typeof(byte[]), typeof(string))]
    public sealed class ByteArrayConverter : IValueConverter
    {
        public byte[] loaded_for_edit = new byte[16];
        public byte[] bytes = new byte[16];
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {
                loaded_for_edit = (byte[])value;
                return BitConverter.ToString((byte[])value).Replace("-", " ");
            }
            catch
            {
                return "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00";
            }
        }
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {
                String hex = (String)value;
                String[] hex_values = hex.Split(" ");
                if (hex_values.Length != 16)
                    return loaded_for_edit;
                bytes = new byte[hex_values.Length];
                for (int i = 0; i < hex_values.Length; i += 1)
                    bytes[i] = System.Convert.ToByte(hex_values[i], 16);
                return bytes;
            }
            catch
            {
                return loaded_for_edit;
            }
        }
    }
}


====================================================================
FILE: ./Converters/ByteGUIDArrayConverter.cs
====================================================================

﻿using System;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    // [ValueConversion(typeof(byte[]), typeof(string))]
    public sealed class ByteGUIDArrayConverter : IValueConverter
    {
        public byte[] loaded_for_edit = new byte[16];
        public byte[] reversedForDisplay = new byte[16];
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            loaded_for_edit = (byte[])value;
            reversedForDisplay[0] = loaded_for_edit[3];
            reversedForDisplay[1] = loaded_for_edit[2];
            reversedForDisplay[2] = loaded_for_edit[1];
            reversedForDisplay[3] = loaded_for_edit[0];
            reversedForDisplay[4] = loaded_for_edit[5];
            reversedForDisplay[5] = loaded_for_edit[4];
            reversedForDisplay[6] = loaded_for_edit[7];
            reversedForDisplay[7] = loaded_for_edit[6];
            for (var i = 8; i < 16; i++)
            {
                reversedForDisplay[i] = loaded_for_edit[i];
            }
            return BitConverter.ToString(reversedForDisplay).Replace("-", " ");
        }
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            try
            {
                String hex = (String)value;
                String[] hex_values = hex.Split(" ");
                if (hex_values.Length != 16)
                    return loaded_for_edit;
                String[] hex_values_reversed = new string[16];
                hex_values_reversed[0] = hex_values[3];
                hex_values_reversed[1] = hex_values[2];
                hex_values_reversed[2] = hex_values[1];
                hex_values_reversed[3] = hex_values[0];
                hex_values_reversed[4] = hex_values[5];
                hex_values_reversed[5] = hex_values[4];
                hex_values_reversed[6] = hex_values[7];
                hex_values_reversed[7] = hex_values[6];
                for (var i = 8; i < 16; i++)
                {
                    hex_values_reversed[i] = hex_values[i];
                }
                byte[] bytes = new byte[hex_values_reversed.Length];
                for (int i = 0; i < hex_values_reversed.Length; i += 1)
                    bytes[i] = System.Convert.ToByte(hex_values_reversed[i], 16);
                return bytes;
            }
            catch
            {
                return loaded_for_edit;
            }
        }
    }
}


====================================================================
FILE: ./Converters/CompareNumbersConverter.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    public class CompareNumbersConverter : IMultiValueConverter
    {
        // these could be overridden on declaration
        public object TrueValue { get; set; } = true;
        public object FalseValue { get; set; } = false;
        
        public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
        {
            double a, b;
            try
            {
                a = (double)(values[0] ?? throw new InvalidOperationException());
                b = (double)(values[1] ?? throw new InvalidOperationException());
            }
            catch
            {
                return null;
            }

            if (parameter is string par)
            {
                int r;
                if (par == ">")      // greater than
                    r = 1;
                else if (par == "<") // less than
                    r = -1;
                else
                    return null;

                bool res = a.CompareTo(b) == r;
                return res ? TrueValue : FalseValue;
            }

            return null;
        }
    }
}


====================================================================
FILE: ./Converters/DataFieldOneTimeConverter.cs
====================================================================

﻿using System;
using System.Globalization;
using System.Reflection;
using Avalonia.Data.Converters;
using UndertaleModLib;

namespace UndertaleModToolAvalonia.Converters
{
    public class DataFieldOneTimeConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is not UndertaleData data || parameter is not string par)
                return null;

            FieldInfo info = data.GetType().GetField(par);
            object resObj = info?.GetValue(data);

            if (resObj is bool res)
                return res;
            else
                return null;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/EqualityConverter.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    public class EqualityConverter : IMultiValueConverter
    {
        public object Convert(IList<object?> values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values == null)
                return values;

            if (values.Count < 2)
                return false;

            bool invert = parameter is string par && par == "invert";
            return (values[0] == values[1]) ^ invert;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/EventNameConverter.cs
====================================================================

﻿using System;
using System.Globalization;
using Avalonia.Data.Converters;
using UndertaleModLib.Models;

namespace UndertaleModToolAvalonia.Converters
{
    //[ValueConversion(typeof(uint), typeof(string))]
    public class EventNameConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (parameter is string par && par == "EventType")
                return Enum.Parse(typeof(EventType), (string)value);

            uint val = System.Convert.ToUInt32(value);
            return ((EventType)val).ToString();
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (uint)(EventType)Enum.Parse(typeof(EventType), (string)value);
        }
    }
}


====================================================================
FILE: ./Converters/ForwardButtonEnabledConverter.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    public class ForwardButtonEnabledConverter : IMultiValueConverter
    {
        public object Convert(IList<object?> values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values[0] is not int pos || values[1] is not int count)
                return false;

            return pos != count - 1;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/GameObjectByIdConverter.cs
====================================================================

﻿using System;
using System.Globalization;
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Data.Converters;
using UndertaleModLib.Models;
using UndertaleModToolAvalonia.Views;

namespace UndertaleModToolAvalonia.Converters
{
    //[ValueConversion(typeof(uint), typeof(UndertaleGameObject))]
    public class GameObjectByIdConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            uint val = System.Convert.ToUInt32(value);
            UndertaleGameObject returnObj = null;
            if (val < AppConstants.Data.GameObjects.Count)
            {
                returnObj = AppConstants.Data.GameObjects[(int)val];
                return returnObj;
            }
            else
            {
                return returnObj;
            }
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (uint)AppConstants.Data.GameObjects.IndexOf((UndertaleGameObject)value);
        }
    }
}


====================================================================
FILE: ./Converters/GridConverter.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Avalonia;
using Avalonia.Data.Converters;

namespace UndertaleModToolAvalonia.Converters
{
    public class GridConverter : IMultiValueConverter
    {
        public object Convert(IList<object?> values, Type targetType, object parameter, CultureInfo culture)
        {
            if (values.Any(x => x is not double))
                return new Rect();

            return new Rect(0, 0, (double)values[0], (double)values[1]);
        }

        public object[] ConvertBack(object value, Type[] targetType, object parameter, CultureInfo culture)
        {
            return null;
        }
    }
}


====================================================================
FILE: ./Converters/ImplementsInterfaceConverter.cs
====================================================================

﻿using Avalonia.Data.Converters;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace UndertaleModToolUniversal.Converters
{
    //[ValueConversion(typeof(object), typeof(bool))]
    public class ImplementsInterfaceConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Type iface = (Type)parameter;
            return iface.IsAssignableFrom(value?.GetType());
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/IsNullConverter.cs
====================================================================

﻿using Avalonia.Data.Converters;
using System;
using System.Globalization;

namespace UndertaleModTool
{
    public class IsNullConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool invert = parameter is string par && par == "True";
            return (value is null) ^ invert;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/MaskImageConverter.cs
====================================================================

﻿using Avalonia;
using Avalonia.Data.Converters;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace UndertaleModToolAvalonia
{
    public class MaskImageConverter : IMultiValueConverter
    {
        public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
        {
            if (values.Any(e => e == AvaloniaProperty.UnsetValue))
            {
                return null;
            }
            
            uint width = (uint)values[0];
            uint height = (uint)values[1];
            byte[] data = (byte[])values[2];
            if (data == null || data.Length != (width + 7) / 8 * height || width == 0 || height == 0)
                return null;
            GCHandle pinnedArray = GCHandle.Alloc(data, GCHandleType.Pinned);
            IntPtr pointer = pinnedArray.AddrOfPinnedObject();
            Bitmap bitmap = new Bitmap(PixelFormat.Rgb565, AlphaFormat.Opaque, pointer, new PixelSize((int)width, (int)height), new Vector(96, 96), (int)((width + 7) / 8));
            pinnedArray.Free();
            return bitmap;
            // Make sure to fix!!!
            // return BitmapSource.Create((int)width, (int)height, 96, 96, PixelFormats.BlackWhite, null, data, (int)((width + 7) / 8));
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}


====================================================================
FILE: ./Converters/NegateNumberConverter.cs
====================================================================

﻿using Avalonia.Data.Converters;
using System;
using System.Globalization;

namespace UndertaleModToolAvalonia
{
    public class NegateNumberConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            double num;
            try
            {
                num = -1 * System.Convert.ToDouble(value);
            }
            catch
            {
                return null;
            }

            if (parameter is string par)
            {
                object res = null;

                try
                {
                    res = par switch
                    {
                        "sbyte" => (sbyte)num,
                        "short" => (short)num,
                        "int" => (int)num,
                        "long" => (long)num,
                        "float" => (float)num,
                        "decimal" => (decimal)num,
                        _ => null
                    };
                }
                catch { }

                return res; 
            }
            else
                return num;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/NullToVisibilityConverter.cs
====================================================================

﻿using Avalonia;
using Avalonia.Data.Converters;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace UndertaleModToolAvalonia
{
    public sealed class NullToVisibilityConverter : IValueConverter
    {
        public bool nullValue { get; } = true;
        public bool notNullValue { get; } = false;

        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return value == null ? nullValue : notNullValue;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/RectConverter.cs
====================================================================

﻿using Avalonia;
using Avalonia.Data.Converters;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace UndertaleModToolAvalonia
{
    public class RectConverter : IMultiValueConverter
    {
        public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
        {
            bool ignore = parameter is string par && par == "returnEmptyOnNull";

            if (values.Any(e => e == AvaloniaProperty.UnsetValue))
            {
                if (ignore)
                    return new Rect(0, 0, 0, 0);
                else
                    return null;
            }

            return new Rect((ushort)values[0], (ushort)values[1], (ushort)values[2], (ushort)values[3]);
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}


====================================================================
FILE: ./Converters/StringTitleConverter.cs
====================================================================

﻿using Avalonia.Data.Converters;
using System;
using System.Globalization;
using System.Text.RegularExpressions;

namespace UndertaleModToolAvalonia
{
    public class StringTitleConverter : IValueConverter
    {
        public static readonly Regex NewLineRegex = new(@"\r\n?|\n", RegexOptions.Compiled);
        public static StringTitleConverter Instance { get; } = new();

        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is not string str)
                return null;

            if (str.Length == 0)
                return "(empty string)";

            if (str.Length > 256)
                str = str[..256] + "...";
            str = NewLineRegex.Replace(str, " ");

            return str;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Converters/SumRectConverter.cs
====================================================================

﻿using Avalonia;
using Avalonia.Data.Converters;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace UndertaleModToolAvalonia
{
    public class SumRectConverter : IMultiValueConverter
    {
        public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
        {
            if (values.Any(e => e == AvaloniaProperty.UnsetValue))
            {
                return null;
            }
            return new Rect((ushort)values[0] + (uint)values[1], (ushort)values[2] + (uint)values[3], (uint)values[4], (uint)values[5]);
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            throw new NotSupportedException();
        }
    }
}


====================================================================
FILE: ./Converters/UndertaleCachedImageLoader.cs
====================================================================

﻿using System;
using System.Buffers;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Data.Converters;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using Avalonia.Threading;
using UndertaleModLib.Models;
using UndertaleModLib.Util;
using UndertaleModToolAvalonia.Utility;
using static UndertaleModLib.Models.UndertaleRoom;

namespace UndertaleModToolAvalonia.Converters
{
    internal class UndertaleCachedImageLoader : IValueConverter
    {
        private static readonly ConcurrentDictionary<string, Bitmap> imageCache = new();
        private static readonly ConcurrentDictionary<Tuple<string, Tuple<uint, uint, uint, uint>>, Bitmap> tileCache = new();
        // private static readonly MainWindow mainWindow = Application.Current.MainWindow as MainWindow;

        private static bool _reuseTileBuffer;
        public static bool ReuseTileBuffer
        {
            get => _reuseTileBuffer;
            set
            {
                sharedTileBuffer = value ? ArrayPool<byte>.Create() : null;

                _reuseTileBuffer = value;
            }
        }
        private static ArrayPool<byte> sharedTileBuffer;
        private static int currBufferSize = 1048576;

        public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            if (value is null)
                return null;

            bool isTile = false;
            bool cacheEnabled = true;
            bool generate = false;

            string par;
            List<Tuple<uint, uint, uint, uint>> tileRectList = null;
            if (parameter is string)
            {
                par = parameter as string;

                isTile = par.Contains("tile");
                cacheEnabled = !par.Contains("nocache");
                generate = par.Contains("generate");
            }
            else if (parameter is List<Tuple<uint, uint, uint, uint>>)
            {
                generate = true;
                tileRectList = parameter as List<Tuple<uint, uint, uint, uint>>;
            }

            Tile tile = null;
            if (isTile)
                tile = value as Tile;

            UndertaleTexturePageItem texture = isTile ? tile.Tpag : value as UndertaleTexturePageItem;
            if (texture is null || texture.TexturePage is null)
                return null;

            string texName = texture.Name?.Content;
            if (texName is null || texName == "PageItem Unknown Index")
            {
                if (generate)
                    Dispatcher.UIThread.InvokeAsync(() =>
                    {
                        return (AppConstants.Data.TexturePageItems.IndexOf(texture) + 1).ToString();
                    });
                else
                    texName = (AppConstants.Data.TexturePageItems.IndexOf(texture) + 1).ToString();

                if (texName == "0")
                    return null;
            }

            if (texture.SourceWidth == 0 || texture.SourceHeight == 0)
                return null;

            if (tileRectList is not null)
            {
                Rect rect = new(texture.SourceX, texture.SourceY, texture.SourceWidth, texture.SourceHeight);
                ProcessTileSet(texName, CreateSpriteBitmap(rect, in texture), tileRectList, texture.TargetX, texture.TargetY);

                return null;
            }

            Bitmap spriteSrc;
            if (isTile)
            {
                if (tileCache.TryGetValue(new(texName, new((uint)tile.SourceX, (uint)tile.SourceY, tile.Width, tile.Height)), out spriteSrc))
                    return spriteSrc;
            }

            if (!imageCache.ContainsKey(texName) || !cacheEnabled)
            {
                Rect rect;

                // how many pixels are out of bounds of tile texture page
                int diffW = 0;
                int diffH = 0;

                if (isTile)
                {
                    diffW = (int)(tile.SourceX + tile.Width - texture.SourceWidth);
                    diffH = (int)(tile.SourceY + tile.Height - texture.SourceHeight);
                    rect = new((int)(texture.SourceX + tile.SourceX), (int)(texture.SourceY + tile.SourceY), (int)tile.Width, (int)tile.Height);
                }
                else
                    rect = new(texture.SourceX, texture.SourceY, texture.SourceWidth, texture.SourceHeight);

                spriteSrc = CreateSpriteSource(in rect, in texture, diffW, diffH, isTile);

                if (cacheEnabled)
                {
                    if (isTile)
                        tileCache.TryAdd(new(texName, new((uint)tile.SourceX, (uint)tile.SourceY, tile.Width, tile.Height)), spriteSrc);
                    else
                        imageCache.TryAdd(texName, spriteSrc);
                }

                if (generate)
                    return null;
                else
                    return spriteSrc;
            }

            return imageCache[texName];
        }

        public static void Reset()
        {
            imageCache.Clear();
            tileCache.Clear();
            ReuseTileBuffer = false;
            currBufferSize = 1048576;
        }

        public static Bitmap CreateSpriteBitmap(Rect rect, in UndertaleTexturePageItem texture, int diffW = 0, int diffH = 0, bool isTile = false)
        {
            GMImage image = texture.TexturePage.TextureData.Image;

            using MemoryStream stream = new(texture.TexturePage.TextureData.Image.ConvertToRawBgra().ToSpan().ToArray());
            Rect temp = rect;
            if (temp.Width == 0)
                temp = temp.WithWidth(1);
            if (temp.Height == 0)
                temp = temp.WithHeight(1);
            //WriteableBitmap spriteBMP = new WriteableBitmap(new PixelSize((int)temp.Width, (int)temp.Height), new Vector(96.0f, 96.0f), Avalonia.Platform.PixelFormat.Rgba8888, Avalonia.Platform.AlphaFormat.Unpremul);

            temp = temp.WithWidth(temp.Width - (diffW > 0 ? diffW : 0));
            temp = temp.WithHeight(temp.Height - (diffH > 0 ? diffH : 0));
            int x = isTile ? texture.TargetX : 0;
            int y = isTile ? texture.TargetY : 0;

            using Bitmap img = new Bitmap(stream);

            using CroppedBitmap g = new CroppedBitmap(img, new PixelRect(x, y, (int)temp.Width, (int)temp.Height));

            return (Bitmap)g.Source;
        }

        private Bitmap CreateSpriteSource(in Rect rect, in UndertaleTexturePageItem texture, int diffW = 0, int diffH = 0, bool isTile = false)
        {
            Bitmap spriteBMP = CreateSpriteBitmap(rect, in texture, diffW, diffH, isTile);

            Bitmap spriteSrc = spriteBMP;

            return spriteSrc;
        }

        private void ProcessTileSet(string textureName, Bitmap bmp, List<Tuple<uint, uint, uint, uint>> tileRectList, int targetX, int targetY)
        {
            var data = BitmapInfo.BitmapToWritableBitmap(bmp);

            int depth = BitmapInfo.GetDepth(bmp);

            int bufferLen = BitmapInfo.GetStride(bmp) * (int)bmp.Size.Height;
            byte[] buffer;
            if (ReuseTileBuffer)
            {
                if (bufferLen > currBufferSize)
                {
                    currBufferSize = bufferLen;
                    sharedTileBuffer = ArrayPool<byte>.Create(currBufferSize, 17); // 17 is default value
                }

                buffer = sharedTileBuffer.Rent(bufferLen);
            }
            else
                buffer = new byte[bufferLen];

            Marshal.Copy(data.Lock().Address, buffer, 0, bufferLen);

            _ = Parallel.ForEach(tileRectList, (tileRect) =>
            {
                int origX = (int)tileRect.Item1;
                int origY = (int)tileRect.Item2;
                int x = origX - targetX;
                int y = origY - targetY;
                int w = (int)tileRect.Item3;
                int h = (int)tileRect.Item4;

                if (w == 0 || h == 0)
                    return;

                // Sometimes, tile size can be bigger than texture size
                // (for example, BG tile of "room_torielroom")
                // Also, it can be out of texture bounds
                // (for example, tile 10055649 of "room_fire_core_topright")
                // (both examples are from Undertale)
                // This algorithm doesn't support that, so this tile will be processed by "CreateSpriteSource()"
                if (w > data.Size.Width || h > data.Size.Height || x < 0 || y < 0 || x + w > data.Size.Width || y + h > data.Size.Height)
                    return;

                int stride = BitmapInfo.GetStride(data);
                int bufferResLen = w * h * depth;
                byte[] bufferRes = ArrayPool<byte>.Shared.Rent(bufferResLen); // may return bigger array than requested

                // Source - https://stackoverflow.com/a/9691388/12136394
                // There was faster solution, but it uses "unsafe" code
                for (int i = 0; i < h; i++)
                {
                    for (int j = 0; j < w * depth; j += depth)
                    {
                        int origIndex = y * stride + i * stride + x * depth + j;
                        int croppedIndex = i * w * depth + j;

                        Buffer.BlockCopy(buffer, origIndex, bufferRes, croppedIndex, depth);
                    }
                }

                //Bitmap tileBMP = new(w, h);
                //BitmapData dataNew = tileBMP.LockBits(new Rectangle(0, 0, w, h), ImageLockMode.WriteOnly, data.PixelFormat);
                var tileBMP = new WriteableBitmap(new PixelSize(w, h), new Vector(96.0f, 96.0f), PixelFormat.Rgba8888, AlphaFormat.Unpremul);
                using var dataNew = tileBMP.Lock();
                Marshal.Copy(bufferRes, 0, dataNew.Address, bufferResLen);
                ArrayPool<byte>.Shared.Return(bufferRes);

                nint bmpPtr = tileBMP.Lock().Address;
                Bitmap spriteSrc = new Bitmap(PixelFormat.Rgba8888, AlphaFormat.Unpremul, bmpPtr, PixelSize.Empty, new Vector(96.0, 96.0), stride);
                tileBMP.Dispose();

                Tuple<string, Tuple<uint, uint, uint, uint>> tileKey = new(textureName, new((uint)origX, (uint)origY, (uint)w, (uint)h));
                tileCache.TryAdd(tileKey, spriteSrc);
            });

            bmp.Dispose();

            if (ReuseTileBuffer)
                sharedTileBuffer.Return(buffer);
        }

        public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}


====================================================================
FILE: ./Messages/GameDataSelectionMessage.cs
====================================================================

﻿using CommunityToolkit.Mvvm.Messaging.Messages;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;
using UndertaleModToolAvalonia.ViewModels.StartPageViewModels;

namespace UndertaleModToolAvalonia.Messages
{
    public class GameDataSelectionMessage : AsyncRequestMessage<GameDataViewModel?>;
}


====================================================================
FILE: ./Models/DataFileItem.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Text;

namespace UndertaleModToolAvalonia.Models
{
    public class DataFileItem
    {
        public string Name { get; set; }

        public string Preview { get; set; }
        
        
    }
}


====================================================================
FILE: ./Models/EditorModels/Description.cs
====================================================================

namespace UndertaleModToolAvalonia.Models.EditorModels;

public class Description
{
    public string Heading { get; private set; }
    public string Message { get; private set; }

    public Description(string heading, string description)
    {
        Heading = heading;
        Message = description;
    }
}

====================================================================
FILE: ./Models/ImageItem.cs
====================================================================

﻿using Avalonia.Media.Imaging;
using System;
using System.Collections.Generic;
using System.Text;

namespace UndertaleModToolUniversal.Models
{
    public class ImageItem
    {
        public string Name { get; set; }
        public Bitmap Image { get; set; }
    }
}


====================================================================
FILE: ./Program.cs
====================================================================

﻿using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using Avalonia;
using System.IO;
using System.Runtime.InteropServices;
using LibMpv.Client;
using log4net;

namespace UndertaleModToolAvalonia
{
    class Program
    {
        public static bool completeFail = false;
        public static string failMessage = string.Empty;
        
        public static string GetExecutableDirectory()
        {
            return Path.GetDirectoryName(Environment.ProcessPath);
        }
        
        // Initialization code. Don't use any Avalonia, third-party APIs or any
        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
        // yet and stuff might break.
        [STAThread]
        public static int Main(string[] args)
        {
            // Figure out cross platform file association for registering the mod tool in Windows, Mac, and Linux as the program to open data.wim files for Undertale.
            
            if (args.Contains("--wait-for-attach"))
            {
                Console.WriteLine("Attach debugger and use 'Set next statement'");
                while (true)
                {
                    Thread.Sleep(100);
                    if (Debugger.IsAttached)
                        break;
                }
            }

            try
            {
                AppDomain currentDomain = default(AppDomain);
                currentDomain = AppDomain.CurrentDomain;
                // Handler for unhandled exceptions.
                currentDomain.UnhandledException += GlobalUnhandledExceptionHandler;
                // Handler for exceptions in threads behind forms.
                var builder = BuildAvaloniaApp();
                // InitMpv();
                return builder.StartWithClassicDesktopLifetime(args);
            }
            catch (Exception e)
            {
                completeFail = true;
                failMessage = e.Message + "\r\n" + e.StackTrace;
                Console.WriteLine(failMessage);
                File.WriteAllText(Path.Combine(GetExecutableDirectory(), "crash.txt"), e.ToString());
                var builder = BuildAvaloniaApp();
                builder.StartWithClassicDesktopLifetime(args);
            }

            return 0;
        }

        private static void GlobalUnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e)
        {
            Exception ex = default(Exception);
            ex = (Exception)e.ExceptionObject;
            ILog log = LogManager.GetLogger(typeof(Program));
            log.Error(ex.Message + "\n" + ex.StackTrace);
            File.WriteAllText(Path.Combine(GetExecutableDirectory(), "crash2.txt"), (ex.ToString() + "\n" + ex.Message + "\n" + ex.StackTrace));
        }

        private static void GlobalThreadExceptionHandler(object sender, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs e)
        {
            Exception ex = default(Exception);
            ex = e.Exception;
            ILog log = LogManager.GetLogger(typeof(Program)); //Log4NET
            log.Error(ex.Message + "\n" + ex.StackTrace);
            File.WriteAllText(Path.Combine(GetExecutableDirectory(), "crash3.txt"), (ex.Message + "\n" + ex.StackTrace));
        }
        
        public static void InitMpv()
        {
            var platform = IntPtr.Size == 8 ? "x86_64" : "x86";
            var platformId = FunctionResolverFactory.GetPlatformId();
            Console.WriteLine("Check system.");
            if (platformId == LibMpvPlatformID.Win32NT)
            {
                Console.WriteLine("Windows is the system.");
                var path = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, platform);
                LibMpv.Client.LibMpv.UseLibMpv(2).UseLibraryPath(path);
            }
            else if (platformId == LibMpvPlatformID.Unix)
            {
                Console.WriteLine("Unix is the system.");
                if (RuntimeInformation.ProcessArchitecture == Architecture.Arm64)
                {
                    Console.WriteLine("arm64 is the system.");
                    var path = $"/usr/lib/aarch64-linux-gnu/";
                    LibMpv.Client.LibMpv.UseLibMpv(2).UseLibraryPath(path);
                }
                else if (RuntimeInformation.ProcessArchitecture == Architecture.X64)
                {
                    Console.WriteLine("x64 is the system.");
                    // var path = $"/usr/lib/{platform}-linux-gnu";
                    var path = $"/usr/lib64/";
                    LibMpv.Client.LibMpv.UseLibMpv(2).UseLibraryPath(path);
                }
            }
        }
        
        // Avalonia configuration, don't remove; also used by visual designer.
        private static AppBuilder BuildAvaloniaApp()
            => AppBuilder.Configure<App>()
                .UsePlatformDetect()
                .LogToTrace();
    }
}


====================================================================
FILE: ./Services/FileService/FileService.cs
====================================================================

﻿#nullable enable
using Avalonia.Controls;
using Avalonia.Platform.Storage;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.Services.FileService
{
    public class FileService : IFileService
    {
        public async Task<IStorageFile?> SaveFileAsync(IStorageProvider storageProvider)
        {
            return await storageProvider.SaveFilePickerAsync(new FilePickerSaveOptions()
            {
                Title = "Save Text File",
                FileTypeChoices = new List<FilePickerFileType>
                {
                    new FilePickerFileType("Wav (*.wav)") { Patterns = new List<string> { "*.wav" } },
                    new FilePickerFileType("Ogg (*.ogg)") { Patterns = new List<string> { "*.ogg" } },
                    new FilePickerFileType("Mp3 (*.mp3)") { Patterns = new List<string> { "*.mp3" } }
                },
                ShowOverwritePrompt = true,
                SuggestedFileName = "Audio",
                DefaultExtension = "*.wav"
            });
        }
        
        public async Task<IReadOnlyList<IStorageFile>> LoadFileAsync(IStorageProvider storageProvider)
        {
            return await storageProvider.OpenFilePickerAsync(new FilePickerOpenOptions()
            {
                AllowMultiple = false,
                Title = "Load reference audio File",
                FileTypeFilter = [
                    new FilePickerFileType("Wav (*.wav)") { Patterns = new List<string> { "*.wav" } },
                    new FilePickerFileType("Ogg (*.ogg)") { Patterns = new List<string> { "*.ogg" } },
                    new FilePickerFileType("Mp3 (*.mp3)") { Patterns = new List<string> { "*.mp3" } }
                ],
                SuggestedFileName = "",
                SuggestedStartLocation = await storageProvider.TryGetWellKnownFolderAsync(WellKnownFolder.Music)//Environment.GetFolderPath(Environment.SpecialFolder.MyMusic)
            });
        }
    }
}


====================================================================
FILE: ./Services/FileService/IFileService.cs
====================================================================

﻿#nullable enable
using System.Collections.Generic;
using Avalonia.Platform.Storage;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.Services.FileService
{
    public interface IFileService
    {
        Task<IStorageFile?> SaveFileAsync(IStorageProvider storageProvider);
        
        Task<IReadOnlyList<IStorageFile>> LoadFileAsync(IStorageProvider storageProvider);
    }
}


====================================================================
FILE: ./Services/LoadingDialogService/ILoadingDialog.cs
====================================================================

namespace UndertaleModToolAvalonia.Services.LoadingDialogService;

public interface ILoadingDialog
{
    
}

====================================================================
FILE: ./Services/LoadingDialogService/LoadingDialog.cs
====================================================================

namespace UndertaleModToolAvalonia.Services.LoadingDialogService;

public class LoadingDialog : ILoadingDialog
{
    
}

====================================================================
FILE: ./Services/PlayerService/IPlayer.cs
====================================================================

﻿using System.IO;

namespace UndertaleModToolAvalonia.Services.PlayerService
{
    internal interface IPlayer
    {
        public void Stop();

        public SFML.Audio.SoundStatus GetPlayStatus();

        public void Play(Stream audio);

        public void PlayPause();

        public float Pitch { get; set; }

        public float Volume { get; set; }
    }
}


====================================================================
FILE: ./Services/PlayerService/MPVSoundPlayer.cs
====================================================================

using System;
using System.IO;
using Avalonia.Platform;
using Avalonia.Threading;
using LibMpv.Client;
using LibMpv.MVVM;
using SFML.Audio;

namespace UndertaleModToolAvalonia.Services.PlayerService;

public class MPVSoundPlayer : BaseMpvContextViewModel
{
    public override void InvokeInUIThread(Action action)
    {
        Dispatcher.UIThread.Invoke(action);
    }

    protected Stream GetAssemblyResource(string name)
    {
        return AssetLoader.Open(new Uri(name));
    }

    public void Play(string filename)
    {
        LoadFile(filename);
        Play();
    }
}

====================================================================
FILE: ./Services/PlayerService/Player.cs
====================================================================

﻿using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using SFML.Audio;

namespace UndertaleModToolAvalonia.Services.PlayerService
{
    public class Player : IPlayer
    {
        private SFML.Audio.Sound sound = new SFML.Audio.Sound();

        private bool playing = false;
        
        private Stream? current;

        public void Stop()
        {
            sound.Stop();
            current?.Close();
        }

        public SFML.Audio.SoundStatus GetPlayStatus()
        {
            return sound.Status;
        }

        public void Play(Stream audio)
        {
            current = audio;
            sound.SoundBuffer = new SoundBuffer(current);
            sound.Play();
            playing = true;
        }

        public void PlayPause()
        {
            if (sound.Status != SFML.Audio.SoundStatus.Stopped)
            {
                if (playing)
                    sound.Pause();
                else
                    sound.Play();
                playing = !playing;
            }
        }

        public float Pitch
        {
            get
            {
                return sound.Pitch;
            }
            set
            {
                sound.Pitch = value;
            }
        }

        public float Volume
        {
            get
            {
                return sound.Volume;
            }
            set
            {
                sound.Volume = value;
            }
        }
    }
}


====================================================================
FILE: ./Services/PlayerService/Sounds.cs
====================================================================

﻿using System;
using Avalonia.Platform;

namespace UndertaleModToolAvalonia.Services.PlayerService
{
    public abstract class Sounds
    {
        public static bool isSoundEnabled = false;

        public static MPVSoundPlayer notify = new MPVSoundPlayer();
        // public static SoundPlayer closeResult = new SoundPlayer(
        //     AvaloniaLocator.Current.GetService<IAssetLoader>().Open(new Uri("resm:JAAYTransdumper.Assets.switch-18.wav")));

        public static void Volume(long vol)
        {
            notify.Volume = vol;
        }

        public static void PlayNotification()
        {
            if (isSoundEnabled)
            {
                notify.Stop();
                // soundSwitchUncheck.Stop();
                // startup.Stop();
                // finishedTest.Stop();
                // Passed.Stop();
                // Failed.Stop();
                // closeResult.Stop();
                notify.Play("Assets/chime-notification.wav");
            }
        }
    }
}


====================================================================
FILE: ./Settings.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using System.Windows;
using Avalonia;
using CommunityToolkit.Mvvm.ComponentModel;
using UndertaleModToolAvalonia.Utility;
using UndertaleModToolAvalonia.Views;

namespace UndertaleModToolAvalonia
{
    public class Settings
    {
        public static string AppDataFolder = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "UndertaleModTool");
        public static string ProfilesFolder = Path.Combine(AppDataFolder, "Profiles");

        // Related to profile system and appdata
        public byte[] MD5PreviouslyLoaded = new byte[13];
        public byte[] MD5CurrentlyLoaded = new byte[15];
        
        public string Version { get; set; } = Assembly.GetEntryAssembly().GetName().Version.ToString();
        public string GameMakerStudioPath { get; set; } = "%appdata%\\GameMaker-Studio";
        public string GameMakerStudio2RuntimesPath { get; set; } = "%systemdrive%\\ProgramData\\GameMakerStudio2\\Cache\\runtimes"; /* Using %systemdrive% here fixes the runtimes not being found when the system drive is not C:\\ */
        public bool AssetOrderSwappingEnabled { get; set; } = false;
        public bool ProfileModeEnabled { get; set; } = false;
        public bool UseGMLCache { get; set; } = false;
        public bool ProfileMessageShown { get; set; } = false;
        public bool AutomaticFileAssociation { get; set; } = true;
        public bool TempRunMessageShow { get; set; } = true;

        // The disk space impact will likely be small for the average user, it should be turned off by default for now.
        // "DeleteOldProfileOnSave" as it currently functions is dangerous to be on by default.
        // Especially if a script makes sweeping changes across the code that are hard to revert.
        // The end user will be blindsided as it currently stands.
        // This can be turned back on by default later if some sort of alternative backup limit is implemented,
        // to provide a buffer, similar to how GMS 1.4 did.
        // Example: 0 (unlimited), 1-20 backups (normal range). If a limit of 20 is set, it will start clearing
        // old backups only after 20 is reached (in the family tree, other unrelated mod families don't count)
        // starting with the oldest, with which one to clear determined from a parenting ledger file
        // (whose implementation does not exist yet).
        //
        // This comment should be cleared in the event that the remedies described are implemented.

        public bool DeleteOldProfileOnSave { get; set; } = false;
        public bool WarnOnClose { get; set; } = true;

        private double _globalGridWidth = 20;
        private double _globalGridHeight = 20;
        public double GlobalGridWidth { get => _globalGridWidth; set { if (value >= 0) _globalGridWidth = value; } }
        public bool GridWidthEnabled { get; set; } = false;
        public double GlobalGridHeight { get => _globalGridHeight; set { if (value >= 0) _globalGridHeight = value; } }
        public bool GridHeightEnabled { get; set; } = false;

        public double GlobalGridThickness { get; set; } = 1;
        public bool GridThicknessEnabled { get; set; } = false;

        public bool CanSave { get; set; } = false;
        
        public bool CanSafelySave { get; set; } = false;
        
        public static Settings Instance;

        public static JsonSerializerOptions JsonOptions = new JsonSerializerOptions
        {
            WriteIndented = true,
            AllowTrailingCommas = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
        };

        public Settings()
        {
            Instance = this;
        }

        public static void Load()
        {
            try
            {
                string path = Path.Combine(AppDataFolder, "settings.json");
                if (!File.Exists(path))
                {
                    new Settings();
                    Save();
                    return;
                }
                byte[] bytes = File.ReadAllBytes(path);
                JsonSerializer.Deserialize<Settings>(bytes, JsonOptions);

                // Handle upgrading settings here when needed
                bool changed = false;
                if (Instance.Version != Assembly.GetEntryAssembly().GetName().Version.ToString())
                {
                    changed = true;
                    // TODO when it becomes necessary
                }

                // Update the version to this version
                Instance.Version = Assembly.GetEntryAssembly().GetName().Version.ToString();
                if (changed)
                    Save();
            } catch (Exception e)
            {
                Application.Current.ShowMessage($"Failed to load settings.json! Using default values.\n{e.Message}");
                new Settings();
            }
        }

        public static void Save()
        {
            try
            {
                Directory.CreateDirectory(AppDataFolder);
                string path = Path.Combine(AppDataFolder, "settings.json");
                byte[] bytes = JsonSerializer.SerializeToUtf8Bytes(Instance, JsonOptions);
                File.WriteAllBytes(path, bytes);
            }
            catch (Exception e)
            {
                Application.Current.ShowMessage($"Failed to save settings.json!\n{e.Message}");
            }
        }
    }
}


====================================================================
FILE: ./Styles/MenuIcons.axaml
====================================================================

<Styles xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
        <Style>
                <Style.Resources>
                        <StreamGeometry x:Key="Navigation">M2.75254822,18 L21.2525482,18 C21.6667618,18 22.0025482,18.3357864 22.0025482,18.75 C22.0025482,19.1296958 21.7203943,19.443491 21.3543188,19.4931534 L21.2525482,19.5 L2.75254822,19.5 C2.33833466,19.5 2.00254822,19.1642136 2.00254822,18.75 C2.00254822,18.3703042 2.2847021,18.056509 2.65077766,18.0068466 L2.75254822,18 L21.2525482,18 L2.75254822,18 Z M2.75254822,11.5030063 L21.2525482,11.5030063 C21.6667618,11.5030063 22.0025482,11.8387927 22.0025482,12.2530063 C22.0025482,12.6327021 21.7203943,12.9464972 21.3543188,12.9961597 L21.2525482,13.0030063 L2.75254822,13.0030063 C2.33833466,13.0030063 2.00254822,12.6672199 2.00254822,12.2530063 C2.00254822,11.8733105 2.2847021,11.5595153 2.65077766,11.5098529 L2.75254822,11.5030063 L21.2525482,11.5030063 L2.75254822,11.5030063 Z M2.75168905,5.0032392 L21.251689,5.0032392 C21.6659026,5.0032392 22.001689,5.33902564 22.001689,5.7532392 C22.001689,6.13293497 21.7195352,6.44673016 21.3534596,6.49639258 L21.251689,6.5032392 L2.75168905,6.5032392 C2.33747549,6.5032392 2.00168905,6.16745276 2.00168905,5.7532392 C2.00168905,5.37354343 2.28384293,5.05974824 2.64991849,5.01008582 L2.75168905,5.0032392 L21.251689,5.0032392 L2.75168905,5.0032392 Z</StreamGeometry>
                        <StreamGeometry x:Key="Projects">M5.5 4.25C5.5 3.83579 5.83579 3.5 6.25 3.5H12V8C12 9.10457 12.8954 10 14 10H18.5V19.75C18.5 20.1642 18.1642 20.5 17.75 20.5H13V22H17.75C18.9926 22 20 20.9926 20 19.75V9.66421C20 9.20009 19.8156 8.75497 19.4874 8.42678L13.5732 2.51256C13.245 2.18437 12.7999 2 12.3358 2H6.25C5.00736 2 4 3.00736 4 4.25V12.2675C4.29418 12.0974 4.63572 12 5.00002 12L5.5 12V4.25ZM17.4393 8.5H14C13.7239 8.5 13.5 8.27614 13.5 8V4.56066L17.4393 8.5Z M4 16V14.5C4 13.6716 4.67157 13 5.5 13H7.5C8.32843 13 9 13.6716 9 14.5V16H10.5C11.3284 16 12 16.6716 12 17.5L12 19H9V18.5C9 18.2239 8.77614 18 8.5 18C8.22386 18 8 18.2239 8 18.5V19H5V18.5C5 18.2239 4.77614 18 4.5 18C4.22386 18 4 18.2239 4 18.5V19H1V17.5C1 16.6716 1.67157 16 2.5 16H4ZM5 14.5V16H8V14.5C8 14.2239 7.77614 14 7.5 14H5.5C5.22386 14 5 14.2239 5 14.5Z M9 20H12L12 21.5C12 22.3284 11.3284 23 10.5 23H2.5C1.67157 23 1 22.3284 1 21.5V20H4V20.5C4 20.7761 4.22386 21 4.5 21C4.77614 21 5 20.7761 5 20.5V20H8V20.5C8 20.7761 8.22386 21 8.5 21C8.77614 21 9 20.7761 9 20.5V20Z</StreamGeometry>
                        <StreamGeometry x:Key="Settings">M14 9.50006C11.5147 9.50006 9.5 11.5148 9.5 14.0001C9.5 16.4853 11.5147 18.5001 14 18.5001C15.3488 18.5001 16.559 17.9066 17.3838 16.9666C18.0787 16.1746 18.5 15.1365 18.5 14.0001C18.5 13.5401 18.431 13.0963 18.3028 12.6784C17.7382 10.8381 16.0253 9.50006 14 9.50006ZM11 14.0001C11 12.3432 12.3431 11.0001 14 11.0001C15.6569 11.0001 17 12.3432 17 14.0001C17 15.6569 15.6569 17.0001 14 17.0001C12.3431 17.0001 11 15.6569 11 14.0001Z M21.7093 22.3948L19.9818 21.6364C19.4876 21.4197 18.9071 21.4515 18.44 21.7219C17.9729 21.9924 17.675 22.4693 17.6157 23.0066L17.408 24.8855C17.3651 25.273 17.084 25.5917 16.7055 25.682C14.9263 26.1061 13.0725 26.1061 11.2933 25.682C10.9148 25.5917 10.6336 25.273 10.5908 24.8855L10.3834 23.0093C10.3225 22.4731 10.0112 21.9976 9.54452 21.7281C9.07783 21.4586 8.51117 21.4269 8.01859 21.6424L6.29071 22.4009C5.93281 22.558 5.51493 22.4718 5.24806 22.1859C4.00474 20.8536 3.07924 19.2561 2.54122 17.5137C2.42533 17.1384 2.55922 16.7307 2.8749 16.4977L4.40219 15.3703C4.83721 15.0501 5.09414 14.5415 5.09414 14.0007C5.09414 13.4598 4.83721 12.9512 4.40162 12.6306L2.87529 11.5051C2.55914 11.272 2.42513 10.8638 2.54142 10.4882C3.08038 8.74734 4.00637 7.15163 5.24971 5.82114C5.51684 5.53528 5.93492 5.44941 6.29276 5.60691L8.01296 6.36404C8.50793 6.58168 9.07696 6.54881 9.54617 6.27415C10.0133 6.00264 10.3244 5.52527 10.3844 4.98794L10.5933 3.11017C10.637 2.71803 10.9245 2.39704 11.3089 2.31138C12.19 2.11504 13.0891 2.01071 14.0131 2.00006C14.9147 2.01047 15.8128 2.11485 16.6928 2.31149C17.077 2.39734 17.3643 2.71823 17.4079 3.11017L17.617 4.98937C17.7116 5.85221 18.4387 6.50572 19.3055 6.50663C19.5385 6.507 19.769 6.45838 19.9843 6.36294L21.7048 5.60568C22.0626 5.44818 22.4807 5.53405 22.7478 5.81991C23.9912 7.1504 24.9172 8.74611 25.4561 10.487C25.5723 10.8623 25.4386 11.2703 25.1228 11.5035L23.5978 12.6297C23.1628 12.95 22.9 13.4586 22.9 13.9994C22.9 14.5403 23.1628 15.0489 23.5988 15.3698L25.1251 16.4965C25.441 16.7296 25.5748 17.1376 25.4586 17.5131C24.9198 19.2536 23.9944 20.8492 22.7517 22.1799C22.4849 22.4657 22.0671 22.5518 21.7093 22.3948ZM16.263 22.1966C16.4982 21.4685 16.9889 20.8288 17.6884 20.4238C18.5702 19.9132 19.6536 19.8547 20.5841 20.2627L21.9281 20.8526C22.791 19.8538 23.4593 18.7013 23.8981 17.4552L22.7095 16.5778L22.7086 16.5771C21.898 15.98 21.4 15.0277 21.4 13.9994C21.4 12.9719 21.8974 12.0195 22.7073 11.4227L22.7085 11.4218L23.8957 10.545C23.4567 9.2988 22.7881 8.14636 21.9248 7.1477L20.5922 7.73425L20.5899 7.73527C20.1844 7.91463 19.7472 8.00722 19.3039 8.00663C17.6715 8.00453 16.3046 6.77431 16.1261 5.15465L16.1259 5.15291L15.9635 3.69304C15.3202 3.57328 14.6677 3.50872 14.013 3.50017C13.3389 3.50891 12.6821 3.57367 12.0377 3.69328L11.8751 5.15452C11.7625 6.16272 11.1793 7.05909 10.3019 7.56986C9.41937 8.0856 8.34453 8.14844 7.40869 7.73694L6.07273 7.14893C5.20949 8.14751 4.54092 9.29983 4.10196 10.5459L5.29181 11.4233C6.11115 12.0269 6.59414 12.9837 6.59414 14.0007C6.59414 15.0173 6.11142 15.9742 5.29237 16.5776L4.10161 17.4566C4.54002 18.7044 5.2085 19.8585 6.07205 20.8587L7.41742 20.2682C8.34745 19.8613 9.41573 19.9215 10.2947 20.4292C11.174 20.937 11.7593 21.832 11.8738 22.84L11.8744 22.8445L12.0362 24.3088C13.3326 24.5638 14.6662 24.5638 15.9626 24.3088L16.1247 22.8418C16.1491 22.6217 16.1955 22.4055 16.263 22.1966Z</StreamGeometry>
                        <StreamGeometry x:Key="Editor">M6.25 3.5C5.83579 3.5 5.5 3.83579 5.5 4.25V19.75C5.5 20.1642 5.83579 20.5 6.25 20.5H10.0293C9.92216 21.0483 10.0375 21.5732 10.3007 22H6.25C5.00736 22 4 20.9926 4 19.75V4.25C4 3.00736 5.00736 2 6.25 2H12.3358C12.7999 2 13.245 2.18437 13.5732 2.51256L19.4874 8.42678C19.8156 8.75497 20 9.20009 20 9.66421V10H19.8698C19.7592 9.99447 19.6484 9.99447 19.5378 10H14C12.8954 10 12 9.10457 12 8V3.5H6.25ZM13.5 4.56066V8C13.5 8.27614 13.7239 8.5 14 8.5H17.4393L13.5 4.56066Z M19.7133 11H19.7154C20.3 11.0003 20.8845 11.2234 21.3305 11.6695C22.2231 12.5621 22.2231 14.0093 21.3305 14.9019L15.4281 20.8043C15.084 21.1485 14.6528 21.3926 14.1806 21.5106L12.3499 21.9683C11.5538 22.1674 10.8326 21.4462 11.0317 20.6501L11.4894 18.8194C11.6074 18.3472 11.8515 17.916 12.1957 17.5719L18.0981 11.6695C18.5441 11.2234 19.1287 11.0003 19.7133 11Z</StreamGeometry>
                </Style.Resources>
        </Style>
</Styles>


====================================================================
FILE: ./Styles/SideBar.axaml
====================================================================

<Styles xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
  <Design.PreviewWith>
    <Border>
      <TabControl Classes="sidebar">
        <TabItem Header="Item1"/>
        <TabItem Header="Item2"/>
      </TabControl>
    </Border>
  </Design.PreviewWith>
  <Style Selector="TabControl.sidebar">
    <Setter Property="TabStripPlacement" Value="Left"/>
    <Setter Property="Padding" Value="0 0 0 0"/>
    <!-- <Setter Property="Background" Value="{TemplateBinding Background}"/> -->
    <Setter Property="Template">
      <ControlTemplate>
        <Border
            Margin="{TemplateBinding Margin}"
            BorderBrush="{TemplateBinding BorderBrush}"
            BorderThickness="{TemplateBinding BorderThickness}">
          <DockPanel>
            <ScrollViewer Width="240" Margin="0 30 0 0"
                Name="PART_ScrollViewer"
                HorizontalScrollBarVisibility="{TemplateBinding (ScrollViewer.HorizontalScrollBarVisibility)}"
                VerticalScrollBarVisibility="{TemplateBinding (ScrollViewer.VerticalScrollBarVisibility)}"
                Background="{TemplateBinding Background}"
                DockPanel.Dock="Left">
              <ItemsPresenter
                  Name="PART_ItemsPresenter"
                  ItemsPanel="{TemplateBinding ItemsPanel}">
              </ItemsPresenter>
            </ScrollViewer>
            <ContentControl Content="{TemplateBinding Tag}" HorizontalContentAlignment="Right" DockPanel.Dock="Bottom"/>
            <ScrollViewer Background="{TemplateBinding Background}"
                HorizontalScrollBarVisibility="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=SelectedItem.(ScrollViewer.HorizontalScrollBarVisibility)}"
                VerticalScrollBarVisibility="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=SelectedItem.(ScrollViewer.VerticalScrollBarVisibility)}">
              <ContentPresenter
                      Name="PART_SelectedContentHost"
                      Margin="{TemplateBinding Padding}"
                      HorizontalContentAlignment="{TemplateBinding HorizontalContentAlignment}"
                      VerticalContentAlignment="{TemplateBinding VerticalContentAlignment}"
                      Content="{TemplateBinding SelectedContent}"
                      ContentTemplate="{TemplateBinding SelectedContentTemplate}">
              </ContentPresenter>
            </ScrollViewer>
          </DockPanel>
        </Border>
      </ControlTemplate>
    </Setter>
  </Style>

  <Style Selector="TabControl.sidebar > TabItem">
    <Setter Property="BorderThickness" Value="0"/>
    <Setter Property="FontSize" Value="14"/>
    <Setter Property="Margin" Value="0"/>
    <Setter Property="Padding" Value="16"/>
    <Setter Property="Width" Value="240" />
    <Setter Property="HorizontalContentAlignment" Value="Stretch" />
    <Setter Property="(ScrollViewer.HorizontalScrollBarVisibility)" Value="Disabled"/>
    <Setter Property="(ScrollViewer.VerticalScrollBarVisibility)" Value="Auto"/>
  </Style>
  <Style Selector="TabControl.sidebar > TabItem:selected /template/ Border#PART_SelectedPipe">
    <Setter Property="IsVisible" Value="False" />
  </Style>
  <Style Selector="TabControl.sidebar > TabItem:selected">
    <!-- <Setter Property="Background" Value="{TemplateBinding Background}"/> -->
  </Style>
<!-- #1fffffff -->
  <Style Selector="TabControl.sidebar > TabItem:pointerover /template/ Border#PART_LayoutRoot">
    <Setter Property="Background" Value="{TemplateBinding Background}"/>
  </Style>
</Styles>
<!-- #3fffffff -->

====================================================================
FILE: ./UndertaleModToolAvalonia.csproj
====================================================================

﻿<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
        <OutputType>Exe</OutputType>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
        <ApplicationManifest>app.manifest</ApplicationManifest>
        <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    </PropertyGroup>

    <ItemGroup>
        <AvaloniaResource Include="Assets\**" />
        <EmbeddedResource Include="Assets\chime-notification.wav" CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Avalonia" Version="11.3.1" />
        <PackageReference Include="Avalonia.Desktop" Version="11.3.1" />
        <PackageReference Include="Avalonia.Themes.Fluent" Version="11.3.1" />
        <PackageReference Include="Avalonia.Fonts.Inter" Version="11.3.1" />
        <!--Condition below is needed to remove Avalonia.Diagnostics package from build output in Release configuration.-->
        <PackageReference Condition="'$(Configuration)' == 'Debug'" Include="Avalonia.Diagnostics" Version="11.3.1" />
        <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
        <PackageReference Include="CSFML" Version="2.6.1" />
        <PackageReference Include="FluentAvalonia.BreadcrumbBar" Version="2.0.2" />
        <PackageReference Include="FluentAvalonia.FluentIcons" Version="1.1.201.1-preview7" />
        <PackageReference Include="FluentAvalonia.ProgressRing" Version="1.69.2" />
        <PackageReference Include="FluentAvaloniaUI" Version="2.3.0" />
        <PackageReference Include="LibMpv.Avalonia" Version="1.0.0" />
        <PackageReference Include="LibMpv.MVVM" Version="1.0.0" />
        <PackageReference Include="log4net" Version="3.1.0" />
        <PackageReference Include="MessageBox.Avalonia" Version="3.2.0" />
        <PackageReference Include="Microsoft.CodeAnalysis" Version="4.14.0" />
        <PackageReference Include="Microsoft.CodeAnalysis.Scripting.Common" Version="4.14.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.6" />
        <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
        <PackageReference Include="SFML.Audio" Version="2.6.1" />
        <PackageReference Include="SixLabors.ImageSharp" Version="3.1.10" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\UndertaleModLib\UndertaleModLib.csproj" />
    </ItemGroup>

    <ItemGroup>
      <Reference Include="log4net">
        <HintPath>..\..\..\.nuget\packages\log4net\3.0.3\lib\netstandard2.0\log4net.dll</HintPath>
      </Reference>
      <Reference Include="Microsoft.CodeAnalysis.Scripting">
        <HintPath>..\..\..\.nuget\packages\microsoft.codeanalysis.scripting.common\4.11.0\lib\net8.0\Microsoft.CodeAnalysis.Scripting.dll</HintPath>
      </Reference>
      <Reference Include="Newtonsoft.Json">
        <HintPath>..\..\..\.nuget\packages\newtonsoft.json\13.0.3\lib\net6.0\Newtonsoft.Json.dll</HintPath>
      </Reference>
    </ItemGroup>

    <ItemGroup>
      <Compile Update="Views\MainWindow.axaml.cs">
        <DependentUpon>MainWindow.axaml</DependentUpon>
        <SubType>Code</SubType>
      </Compile>
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Controls\" />
    </ItemGroup>
</Project>


====================================================================
FILE: ./Utilities/AssetGrabber.cs
====================================================================

using System;
using System.IO;
using System.Reflection;
using SkiaSharp;

namespace AAYInvisionaryTTSPlayer.Utilities;

public static class AssetGrabber
{
    public static Stream GetAssetStream(string filename)
    {
        var info = Assembly.GetExecutingAssembly().GetName();  
        var name = info.Name;  
        return Assembly.GetExecutingAssembly().GetManifestResourceStream($"{name}.Assets.{filename}")!;
    }
    
    // Helper methods (placeholders)
    public static SKBitmap LoadImage(string assetPath ,string name)
    {
        try
        {
            return SKBitmap.Decode(GetAssetStream($"{assetPath}.{name}")); // Adjust path as needed
        }
        catch (Exception)
        {
            //Console.WriteLine(e);
            return SKBitmap.Decode(GetAssetStream($"Assets\\AAYicon.ico")); // Adjust path as needed
        }
    }

    public static Stream LoadSound(string assetPath, string name)
    {
        try
        {
            return GetAssetStream($"{assetPath}.{name}"); // Adjust path as needed
        }
        catch (Exception e)
        {
            Console.WriteLine(e + "\n No Sound Found");
            return Stream.Null;
        }
    }
    
    public static void PlaySound(string name) => Console.WriteLine($"Playing {name}"); // Replace with actual audio library
}

====================================================================
FILE: ./Utilities/EmbeddedFetcher.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AAYInvisionaryTTSPlayer.Utilities
{
    public static class EmbeddedFetcher
    {
        public static byte[] ExtractResource(string filename)
        {
            using (Stream resFilestream = AssetGrabber.GetAssetStream(filename))
            {
                if (resFilestream == null) return new byte[4] { 0, 0, 0, 0 };
                byte[] ba = new byte[resFilestream.Length];
                resFilestream.Read(ba, 0, ba.Length);
                return ba;
            }
        }
    }
}


====================================================================
FILE: ./Utility/BitmapInfo.cs
====================================================================

﻿using Avalonia;
using Avalonia.Media.Imaging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.Utility
{
    public class BitmapInfo
    {
        private BitmapInfo() { }

        public static int GetDepth(Avalonia.Media.Imaging.Bitmap bitmap)
        {
            using (var memoryStream = new MemoryStream())
            {
                bitmap.Save(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                using (var image = SixLabors.ImageSharp.Image.Load(memoryStream))
                {
                    return image.PixelType.BitsPerPixel / 8;
                }
            }
        }

        public static Avalonia.Media.Imaging.WriteableBitmap BitmapToWritableBitmap(Avalonia.Media.Imaging.Bitmap bitmap)
        {
            using (var memoryStream = new MemoryStream())
            {
                bitmap.Save(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                return Avalonia.Media.Imaging.WriteableBitmap.Decode(memoryStream);
            }
        }

        //public static Avalonia.Media.Imaging.WriteableBitmap ByteDataToBlackAndWhiteBitmap(byte[] data, int width, int height)
        //{
        //    using (var memoryStream = new MemoryStream(data))
        //    {
        //        memoryStream.Seek(0, SeekOrigin.Begin);
        //        // return 
        //        var wb = Avalonia.Media.Imaging.WriteableBitmap.Decode(memoryStream);
        //        using (MemoryStream ms = new MemoryStream(data))
        //        {
        //            new WriteableBitmap(new PixelSize((int)width, (int)height), new Vector(96, 96), Avalonia.Platform.PixelFormat.Rgb565, Avalonia.Platform.AlphaFormat.Opaque);

        //        }
        //        return (, , PixelFormats.BlackWhite, null, data, (int)((width + 7) / 8));
        //    }
        //}

        public static int GetStride(Avalonia.Media.Imaging.Bitmap bitmap)
        {
            using (var memoryStream = new MemoryStream())
            {
                bitmap.Save(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                var image = SixLabors.ImageSharp.Image.Load(memoryStream);
                return (image.PixelType.BitsPerPixel / 8) * image.Width;
            }
        }

        public static int GetStride(Avalonia.Media.Imaging.WriteableBitmap bitmap)
        {
            using (var memoryStream = new MemoryStream())
            {
                bitmap.Save(memoryStream);
                memoryStream.Seek(0, SeekOrigin.Begin);
                var image = SixLabors.ImageSharp.Image.Load(memoryStream);
                return (image.PixelType.BitsPerPixel / 8) * image.Width;
            }
        }
    }
}


====================================================================
FILE: ./Utility/ImageHelper.cs
====================================================================

﻿using Avalonia.Media.Imaging;
using Avalonia.Platform;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.Utility
{
    internal class ImageHelper
    {
        public static Bitmap LoadFromResource(Uri resourceUri)
        {
            return new Bitmap(AssetLoader.Open(resourceUri));
        }

        public static async Task<Bitmap?> LoadFromWeb(Uri url)
        {
            using var httpClient = new HttpClient();
            try
            {
                var response = await httpClient.GetAsync(url);
                response.EnsureSuccessStatusCode();
                var data = await response.Content.ReadAsByteArrayAsync();
                return new Bitmap(new MemoryStream(data));
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"An error occurred while downloading image '{url}' : {ex.Message}");
                return null;
            }
        }
    }
}


====================================================================
FILE: ./Utility/LoaderDialogFactory.cs
====================================================================

﻿using Avalonia.Controls;
using Avalonia.Threading;
using Avalonia.X11;
using log4net;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Avalonia;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;
using UndertaleModToolAvalonia.Views;
using UndertaleModToolAvalonia.Views.EditorViews;

namespace UndertaleModToolAvalonia.Utility
{
    public class LoaderDialogFactory
    {
        private static LoaderDialogView loaderDialogView;

        private static LoaderDialogViewModel loaderDialogViewModel;

        private static CancellationTokenSource cts;

        private static CancellationToken cToken;

        private static int progressValue;

        private static Task updater;

        private static bool preventClose;

        public static bool Created { get; set; } = false;

        public static bool IsClosed { get; set; } = false;

        private LoaderDialogFactory() {}

        /*public static async void Create(Window perent, bool preventClose = false, string title = "", string msg = "")
        {
            if (!Created || IsClosed)
            {
                if (loaderDialogView is null)
                    loaderDialogView = (LoaderDialogView?)await WindowLoader.createWindowAsync(perent,
                                    typeof(LoaderDialogView), typeof(LoaderDialogViewModel), true, true, title, msg);
                if (loaderDialogViewModel is null)
                    loaderDialogViewModel = loaderDialogView.DataContext as LoaderDialogViewModel;
                else
                    loaderDialogView.DataContext = loaderDialogViewModel;

                loaderDialogView.Closing += OnClosing;
                loaderDialogView.Closed += OnClosed;
                LoaderDialogFactory.preventClose = preventClose;
                Created = true;
                IsClosed = false;
                await loaderDialogView.ShowDialog(perent);
            }
            else
                await loaderDialogView.ShowDialog(perent);
        }*/

        private static void OnClosed(object? sender, EventArgs e)
        {
            IsClosed = true;
        }

        private static void OnClosing(object? sender, CancelEventArgs e)
        {
            e.Cancel = preventClose;
        }

        public static void HideProgressBar()
        {
            if (loaderDialogView != null)
                loaderDialogView.Hide();
        }

        public static async Task UpdateProgressBar(string message, string status, double progressValue, double maxValue)
        {
            if (loaderDialogViewModel != null)
            {
                await Dispatcher.UIThread.InvokeAsync((Action)(async () =>
                {
                    await loaderDialogViewModel.Update(message, status, progressValue, maxValue);
                }), DispatcherPriority.Normal);
            }
        }

        public static async Task SetProgressBar(string message, string status, double progressValue, double maxValue)
        {
            if (loaderDialogViewModel != null)
            {
                await loaderDialogViewModel.UpdateValue(progressValue);
                loaderDialogViewModel.SavedStatusText = status;

                await UpdateProgressBar(message, status, progressValue, maxValue);
            }
        }
        public static async Task SetProgressBar()
        {
            if (loaderDialogView != null && !loaderDialogView.IsVisible)
                await Dispatcher.UIThread.InvokeAsync(loaderDialogView.Show);
        }

        public static async Task UpdateProgressValue(double progressValue)
        {
            if (loaderDialogViewModel != null)
            {
                await Dispatcher.UIThread.InvokeAsync((Action)(async () =>
                {
                    await loaderDialogViewModel.ReportProgress(progressValue);
                }), DispatcherPriority.Normal);
            }
        }

        public static async Task UpdateProgressStatus(string status)
        {
            if (loaderDialogViewModel != null)
            {
                await Dispatcher.UIThread.InvokeAsync((Action)(async () =>
                {
                    await loaderDialogViewModel.ReportProgress(status);
                }), DispatcherPriority.Normal);
            }
        }

        private static void ProgressUpdater()
        {
            DateTime prevTime = default;
            int prevValue = 0;

            while (true)
            {
                if (cToken.IsCancellationRequested)
                {
                    if (prevValue >= progressValue) //if reached maximum
                        return;
                    else
                    {
                        if (prevTime == default)
                            prevTime = DateTime.UtcNow;                                       //begin measuring
                        else if (DateTime.UtcNow.Subtract(prevTime).TotalMilliseconds >= 500) //timeout - 0.5 seconds
                            return;
                    }
                }

                _ = UpdateProgressValue(progressValue);

                prevValue = progressValue;

                Thread.Sleep(100); //10 times per second
            }
        }

        public static void StartProgressBarUpdater()
        {
            if (cts is not null)
                Application.Current.ShowMessage("Warning - there is another progress bar updater task running (hangs) in the background.\nRestart the application to prevent some unexpected behavior.");

            cts = new CancellationTokenSource();
            cToken = cts.Token;

            updater = Task.Run(ProgressUpdater);
        }

        public static async Task StopProgressBarUpdater() //async because "Wait()" blocks UI thread
        {
            if (cts is null) return;

            cts.Cancel();

            if (await Task.Run(() => !updater.Wait(2000))) //if ProgressUpdater isn't responding
                await Application.Current.ShowMessage("Stopping the progress bar updater task is failed.\nIt's highly recommended to restart the application.");
            else
            {
                cts.Dispose();
                cts = null;
            }

            updater.Dispose();
        }

        public static void Hide()
        {
            loaderDialogViewModel.State = WindowState.Minimized;
        }
        
        public static void Show()
        {
            loaderDialogViewModel.State = WindowState.Normal;
        }
        
        public static void Dispose()
        {
            loaderDialogView.Close();
            loaderDialogView = null;
            loaderDialogViewModel = null;
            Created = false;
            IsClosed = false;
        }
    }
}


====================================================================
FILE: ./Utility/MD5HashManager.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.Utility
{
    public static class MD5HashManager
    {
        
        public static string GenerateMD5(string filename)
        {
            using (MD5 md5 = MD5.Create())
            {
                using (FileStream fs = File.OpenRead(filename))
                {
                    byte[] hash = md5.ComputeHash(fs);
                    return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                }
            }
        }
    }
}


====================================================================
FILE: ./Utility/MessageBoxExtensions.cs
====================================================================

using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using MsBox.Avalonia;
using MsBox.Avalonia.Enums;

namespace UndertaleModToolAvalonia.Utility;

/// <summary>
/// Provides <see cref="MessageBoxManager"/> extensions for <see cref="Application"/>s.
/// </summary>
public static class MessageBoxExtensions
{
    /// <summary>
		/// Shows an informational <see cref="MessageBoxManager"/> with <paramref name="app"/> as the parent.
		/// </summary>
		/// <param name="app">The parent from which the <see cref="MessageBoxManager"/> will show.</param>
		/// <param name="messageBoxText">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <returns><see cref="ButtonEnum.Ok"/> or <see cref="ButtonResult.None"/> if
		/// the <see cref="MessageBoxManager"/> was cancelled.</returns>
		public static async Task<ButtonResult> ShowMessage(this Application app, string messageBoxText, string title = "UndertaleModTool")
		{
			return await ShowCore(app, messageBoxText, title, ButtonEnum.Ok, Icon.Info);
		}

		/// <summary>
		/// Shows a <see cref="MessageBoxManager"/> prompting for a yes/no question with <paramref name="app"/> as the parent.
		/// </summary>
		/// <param name="app">The parent from which the <see cref="MessageBoxManager"/> will show.</param>
		/// <param name="messageBoxText">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="icon">The <see cref="Icon"/> to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <returns><see cref="ButtonResult.Yes"/> or <see cref="ButtonResult.No"/> depending on the users' answer.
		/// <see cref="ButtonResult.None"/> if the <see cref="MessageBoxManager"/> was cancelled.</returns>
		public static async Task<ButtonResult> ShowQuestion(this Application app, string messageBoxText, Icon icon = Icon.Question, string title = "UndertaleModTool")
		{
			return await ShowCore(app, messageBoxText, title, ButtonEnum.YesNo, icon);
		}

		/// <summary>
		/// Shows a <see cref="MessageBoxManager"/> prompting for a yes/no/cancel question with <paramref name="app"/> as the parent.
		/// </summary>
		/// <param name="app">The parent from which the <see cref="MessageBoxManager"/> will show.</param>
		/// <param name="messageBoxText">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="icon">The <see cref="Icon"/> to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <returns/><see cref="ButtonResult.Yes"/>, <see cref="ButtonResult.No"/> or <see cref="ButtonResult.Cancel"/> depending on the users' answer.
		public static async Task<ButtonResult> ShowQuestionWithCancel(this Application app, string messageBoxText, Icon icon = Icon.Question, string title = "UndertaleModTool")
		{
			return await ShowCore(app, messageBoxText, title, ButtonEnum.YesNoCancel, icon);
		}

		/// <summary>
		/// Shows a warning <see cref="MessageBoxManager"/> with <paramref name="app"/> as the parent.
		/// </summary>
		/// <param name="app">The parent from which the <see cref="MessageBoxManager"/> will show.</param>
		/// <param name="messageBoxText">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <returns><see cref="ButtonResult.Ok"/> or <see cref="ButtonResult.None"/> if
		/// the <see cref="MessageBoxManager"/> was cancelled.</returns>
		public static async Task<ButtonResult> ShowWarning(this Application app, string messageBoxText, string title = "Warning")
		{
			return await ShowCore(app, messageBoxText, title, ButtonEnum.Ok, Icon.Warning);
		}

		/// <summary>
		/// Shows an error <see cref="MessageBoxManager"/> with <paramref name="app"/> as the parent.
		/// </summary>
		/// <param name="app">The parent from which the <see cref="MessageBoxManager"/> will show.</param>
		/// <param name="messageBoxText">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <returns><see cref="ButtonResult.Ok"/> or <see cref="ButtonResult.None"/> if
		/// the <see cref="MessageBoxManager"/> was cancelled.</returns>
		public static async Task<ButtonResult> ShowError(this Application app, string messageBoxText, string title = "Error")
		{
			return await ShowCore(app, messageBoxText, title, ButtonEnum.Ok, Icon.Error);
		}

		/// <summary>
		/// The wrapper for the extensions to directly call <see cref="MessageBoxManager.GetMessageBoxStandard(string, string, ButtonEnum, Icon, WindowStartupLocation)"/> and it's ShowAsync method.
		/// </summary>
		/// <param name="app">The app that represents the owner of the message box.</param>
		/// <param name="text">A <see cref="string"/> that specifies the text to display.</param>
		/// <param name="title">A <see cref="string"/> that specifies the title bar caption to display.</param>
		/// <param name="buttons">A <see cref="ButtonEnum"/> value that specifies which button or buttons to display.</param>
		/// <param name="image">A <see cref="Icon"/> value that specifies the icon to display.</param>
		/// <returns>A task of <see cref="ButtonResult"/> value that specifies which message box button is clicked by the user.</returns>
		private static async Task<ButtonResult> ShowCore(this Application app, string text, string title, ButtonEnum buttons, Icon image)
		{
			return await MessageBoxManager.GetMessageBoxStandard(title, text, buttons, image).ShowAsync();
		}
}

====================================================================
FILE: ./Utility/ProfileManager.cs
====================================================================

using System;
using System.IO;
using System.Security.Cryptography;
using System.Threading.Tasks;
using UndertaleModLib;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;

namespace UndertaleModToolAvalonia.Utility;

public class ProfileManager
{
//     private static async void UpdateProfile(UndertaleData data, string filename)
//     {
//         await LoaderDialogFactory.UpdateProgressStatus("Calculating MD5 hash...");
//
//         try
//         {
//             await Task.Run(() =>
//             {
//                 using (var md5Instance = MD5.Create())
//                 {
//                     using (var stream = File.OpenRead(filename))
//                     {
//                         Settings.Instance.MD5CurrentlyLoaded = md5Instance.ComputeHash(stream);
//                         Settings.Instance.MD5PreviouslyLoaded = Settings.Instance.MD5CurrentlyLoaded;
//                         Settings.Instance.ProfileHash = BitConverter.ToString(Settings.Instance.MD5PreviouslyLoaded).Replace("-", "").ToLowerInvariant();
//                     }
//                 }
//             });
//
//             string profDir = Path.Combine(ProfilesFolder, ProfileHash);
//             string profDirTemp = Path.Combine(profDir, "Temp");
//             string profDirMain = Path.Combine(profDir, "Main");
//
//             if (ProfileViewModel.ProfileModeEnabled)
//             {
//                 Directory.CreateDirectory(ProfilesFolder);
//                 if (Directory.Exists(profDir))
//                 {
//                     if (!Directory.Exists(profDirTemp) && Directory.Exists(profDirMain))
//                     {
//                         // Get the subdirectories for the specified directory.
//                         DirectoryInfo dir = new DirectoryInfo(profDirMain);
//                         Directory.CreateDirectory(profDirTemp);
//                         // Get the files in the directory and copy them to the new location.
//                         FileInfo[] files = dir.GetFiles();
//                         foreach (FileInfo file in files)
//                         {
//                             string tempPath = Path.Combine(profDirTemp, file.Name);
//                             file.CopyTo(tempPath, false);
//                         }
//                     }
//                     else if (!Directory.Exists(profDirMain) && Directory.Exists(profDirTemp))
//                     {
//                         // Get the subdirectories for the specified directory.
//                         DirectoryInfo dir = new DirectoryInfo(profDirTemp);
//                         Directory.CreateDirectory(profDirMain);
//                         // Get the files in the directory and copy them to the new location.
//                         FileInfo[] files = dir.GetFiles();
//                         foreach (FileInfo file in files)
//                         {
//                             string tempPath = Path.Combine(profDirMain, file.Name);
//                             file.CopyTo(tempPath, false);
//                         }
//                     }
//
//                     // First generation no longer exists, it will be generated on demand while you edit.
//                     Directory.CreateDirectory(profDir);
//                     Directory.CreateDirectory(profDirMain);
//                     Directory.CreateDirectory(profDirTemp);
//                     if (!Directory.Exists(profDir) || !Directory.Exists(profDirMain) || !Directory.Exists(profDirTemp))
//                     {
//                         Application.Current.ShowMessage("Profile should exist, but does not. Insufficient permissions? Profile mode is disabled.");
//                         ProfileViewModel.ProfileModeEnabled = false;
//                         return;
//                     }
//
//                     if (!ProfileViewModel.ProfileMessageShown)
//                     {
//                         Application.Current.ShowMessage(@"The profile for your game loaded successfully!
//
// UndertaleModTool now uses the ""Profile"" system by default for code.
// Using the profile system, many new features are available to you!
// For example, the code is fully editable (you can even add comments)
// and it will be saved exactly as you wrote it. In addition, if the
// program crashes or your computer loses power during editing, your
// code edits will be recovered automatically the next time you start
// the program.
//
// The profile system can be toggled on or off at any time by going
// to the ""File"" tab at the top and then opening the ""Settings""
// (the ""Enable profile mode"" option toggles it on or off).
// You may wish to disable it for purposes such as collaborative
// modding projects, or when performing technical operations.
// For more in depth information, please read ""About_Profile_Mode.txt"".
//
// It should be noted that this system is somewhat experimental, so
// should you encounter any problems, please let us know or leave
// an issue on GitHub.");
//                         ProfileViewModel.ProfileMessageShown = true;
//                     }
//                     CreateUMTLastEdited(filename);
//                 }
//             }
//         }
//         catch (Exception)
//         {
//
//             throw;
//         }
//     }
}

====================================================================
FILE: ./Utility/ScriptMessages.cs
====================================================================

using System;
using System.IO;
using Avalonia;
using Avalonia.Platform;
using MsBox.Avalonia.Enums;
using UndertaleModToolAvalonia.Services.PlayerService;

namespace UndertaleModToolAvalonia.Utility;

public static class ScriptMessages
{
    private static MPVSoundPlayer player = new MPVSoundPlayer();
    
    public static void ScriptMessage(string message)
    {
        Application.Current.ShowMessage(message, "Script message");
    }
    public static bool ScriptQuestion(string message)
    {
        PlayInformationSound();
        return Application.Current.ShowQuestion(message, Icon.Question, "Script Question").Result == ButtonResult.Yes;
    }
    public static void ScriptWarning(string message)
    {
        Application.Current.ShowWarning(message, "Script warning");
    }
    public static void ScriptError(string error, string title = "Error", bool SetConsoleText = true)
    {
        Application.Current.ShowError(error, title);
    }
    
    public static void PlayInformationSound()
    {
        try
        {
            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                player.Play(@"C:\Windows\Media\Windows Exclamation.wav");
            else
                player.Play("Assets/chime-notification.wav"); // Chime Notification by Jofae -- https://freesound.org/s/380482/ -- License: Creative Commons 0
        }
        catch (Exception e)
        {
            Console.WriteLine(e + "\n");
            //throw;
        }
    }
}

====================================================================
FILE: ./Utility/UndertaleHelper.cs
====================================================================

﻿using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Runtime;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using Avalonia.Threading;
using Microsoft.Win32;
using UndertaleModLib;
using UndertaleModLib.Decompiler;
using UndertaleModLib.Util;
using UndertaleModToolAvalonia.Converters;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;

namespace UndertaleModToolAvalonia.Utility
{
    public static class UndertaleHelper
    {
        private static List<(GMImage, WeakReference<Bitmap>)> _bitmapSourceLookup { get; } = new();
        private static object _bitmapSourceLookupLock = new();

        public static bool IsGMS2 => (AppConstants.Data?.GeneralInfo?.Major ?? 0) >= 2 ? true : false;
        
        // God this is so ugly, if there's a better way, please, put in a pull request
        public static bool IsExtProductIDEligible => (((AppConstants.Data?.GeneralInfo?.Major ?? 0) >= 2) || (((AppConstants.Data?.GeneralInfo?.Major ?? 0) == 1) && (((AppConstants.Data?.GeneralInfo?.Build ?? 0) >= 1773) || ((AppConstants.Data?.GeneralInfo?.Build ?? 0) == 1539)))) ? true : false;
        
        public static bool GMLCacheEnabled => Settings.Instance.UseGMLCache;
        
        private static string ExePath { get; } = Program.GetExecutableDirectory();
        
        // For delivering messages to LoaderDialogs
        public delegate void FileMessageEventHandler(string message);
        public static event FileMessageEventHandler FileMessageEvent;
        
        /// <summary>
        /// Returns a <see cref="BitmapSource"/> instance for the given <see cref="GMImage"/>.
        /// If a previously-created instance has not yet been garbage collected, this will return that instance.
        /// </summary>
        public static Bitmap GetBitmapSourceForImage(GMImage image)
        {
            lock (_bitmapSourceLookupLock)
            {
                // Look through entire list, clearing out old weak references, and potentially finding our desired source
                Bitmap foundSource = null;
                for (int i = _bitmapSourceLookup.Count - 1; i >= 0; i--)
                {
                    (GMImage imageKey, WeakReference<Bitmap> referenceVal) = _bitmapSourceLookup[i];
                    if (!referenceVal.TryGetTarget(out Bitmap source))
                    {
                        // Clear out old weak reference
                        _bitmapSourceLookup.RemoveAt(i);
                    }
                    else if (imageKey == image)
                    {
                        // Found our source, store it to return later
                        foundSource = source;
                    }
                }

                // If we found our source, return it
                if (foundSource is not null)
                {
                    return foundSource;
                }

                // If no source was found, then create a new one
                byte[] pixelData = image.ConvertToRawBgra().ToSpan().ToArray();
                //Bitmap bitmap = new Bitmap(new Avalonia.PixelSize(image.Width, image.Height), new Avalonia.Vector(96, 96), PixelFormat.Bgra8888, AlphaFormat.Unpremul);   //(image.Width, image.Height, 96, 96, PixelFormats.Bgra32, null, pixelData, image.Width * 4);
                
                GCHandle pinnedArray = GCHandle.Alloc(pixelData, GCHandleType.Pinned);
                IntPtr pointer = pinnedArray.AddrOfPinnedObject();
                Bitmap bitmap = new Bitmap(PixelFormat.Bgra8888, AlphaFormat.Unpremul, pointer, new PixelSize(image.Width, image.Height), new Vector(96, 96), image.Width * 4);
                pinnedArray.Free();
                _bitmapSourceLookup.Add((image, new WeakReference<Bitmap>(bitmap)));
                return bitmap;
            }
        }
        
        private static void DisposeGameData()
        {
            if (AppConstants.Data is not null)
            {
                // TODO Implement the tabs
                // This also clears all their game object references
                // CurrentTab = null;
                // Tabs.Clear();
                // ClosedTabsHistory.Clear();

                // Update GUI and wait for all background processes to finish
                Dispatcher.UIThread.Invoke(() => { }, DispatcherPriority.ApplicationIdle);

                AppConstants.Data.Dispose();
                AppConstants.Data = null;

                GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
                GC.Collect();
            }
        }
        
        
//         private static async Task LoadFile(string filename, bool preventClose = false, bool onlyGeneralInfo = false)
//         {
//             LoaderDialogFactory.Create(Application.Current?.ApplicationLifetime as Window, preventClose, "Loading", "Loading, please wait...");
//
//             DisposeGameData();
//             // Highlighted = new Description("Welcome to UndertaleModTool!", "Double click on the items on the left to view them!");
//             // OpenInTab(Highlighted);
//
//             Task t = Task.Run(() =>
//             {
//                 bool hadWarnings = false;
//                 UndertaleData data = null;
//                 try
//                 {
//                     using (var stream = new FileStream(filename, FileMode.Open, FileAccess.Read))
//                     {
//                         data = UndertaleIO.Read(stream, warning =>
//                         {
//                             Application.Current.ShowWarning(warning, "Loading warning");
//                             if (warning.Contains("unserializeCountError.txt")
//                                 || warning.Contains("object pool size"))
//                                 return;
//
//                             hadWarnings = true;
//                         }, message =>
//                         {
//                             FileMessageEvent?.Invoke(message);
//                         }, onlyGeneralInfo);
//                     }
//                 }
//                 catch (Exception e)
//                 {
// #if DEBUG
//                     Debug.WriteLine(e);
// #endif
//                     Application.Current.ShowError("An error occured while trying to load:\n" + e.Message, "Load error");
//                 }
//
//                 if (onlyGeneralInfo)
//                 {
//                     Dispatcher.UIThread.Invoke(() =>
//                     {
//                         LoaderDialogFactory.Hide();
//                         AppConstants.Data = data;
//                         AppConstants.FilePath = filename;
//                     });
//
//                     return;
//                 }
//
//                 Dispatcher.UIThread.InvokeAsync(() =>
//                 {
//                     if (data != null)
//                     {
//                         if (data.UnsupportedBytecodeVersion)
//                         {
//                             Application.Current.ShowWarning("Only bytecode versions 13 to 17 are supported for now, you are trying to load " + data.GeneralInfo.BytecodeVersion + ". A lot of code is disabled and will likely break something. Saving/exporting is disabled.", "Unsupported bytecode version");
//                             Settings.Instance.CanSave = false;
//                             Settings.Instance.CanSafelySave = false;
//                         }
//                         else if (hadWarnings)
//                         {
//                             Application.Current.ShowWarning("Warnings occurred during loading. Data loss will likely occur when trying to save!", "Loading problems");
//                             Settings.Instance.CanSave = true;
//                             Settings.Instance.CanSafelySave = false;
//                         }
//                         else
//                         {
//                             Settings.Instance.CanSave = true;
//                             Settings.Instance.CanSafelySave = true;
//                             UpdateProfile(data, filename);
//                             if (data != null)
//                             {
//                                 data.ToolInfo.ProfileMode = Settings.Instance.ProfileModeEnabled;
//                                 data.ToolInfo.CurrentMD5 = BitConverter.ToString(Settings.Instance.MD5CurrentlyLoaded).Replace("-", "").ToLowerInvariant();
//                             }
//                         }
//                         if (data.IsYYC())
//                         {
//                             Application.Current.ShowWarning("This game uses YYC (YoYo Compiler), which means the code is embedded into the game executable. This configuration is currently not fully supported; continue at your own risk.", "YYC");
//                         }
//                         if (data.GeneralInfo != null)
//                         {
//                             if (!data.GeneralInfo.IsDebuggerDisabled)
//                             {
//                                 Application.Current.ShowWarning("This game is set to run with the GameMaker Studio debugger and the normal runtime will simply hang after loading if the debugger is not running. You can turn this off in General Info by checking the \"Disable Debugger\" box and saving.", "GMS Debugger");
//                             }
//                         }
//                         if (Path.GetDirectoryName(AppConstants.FilePath) != Path.GetDirectoryName(filename))
//                             CloseChildFiles();
//
//                         if (AppConstants.FilePath != filename)
//                             SaveGMLCache(AppConstants.FilePath, false, dialog);
//
//                         AppConstants.Data = data;
//
//                         LoadGMLCache(filename, dialog);
//                         UndertaleCachedImageLoader.Reset();
//                         CachedTileDataLoader.Reset();
//
//                         AppConstants.Data.ToolInfo.AppDataProfiles = Settings.ProfilesFolder;
//                         AppConstants.FilePath = filename;
//                         // TODO Not sure if needed.
//                         // OnPropertyChanged("Data");
//                         // OnPropertyChanged("FilePath");
//                         // OnPropertyChanged("IsGMS2");
//
//                         BackgroundsItemsList.Header = IsGMS2 ? "Tile sets" : "Backgrounds & Tile sets";
//
//                         #pragma warning disable CA1416
//                         UndertaleCodeEditor.gettext = null;
//                         UndertaleCodeEditor.gettextJSON = null;
//                         #pragma warning restore CA1416
//                     }
//
//                     dialog.Hide();
//                 });
//             });
//             dialog.ShowDialog();
//             await t;
//
//             // Clear "GC holes" left in the memory in process of data unserializing
//             // https://docs.microsoft.com/en-us/dotnet/api/system.runtime.gcsettings.largeobjectheapcompactionmode?view=net-6.0
//             GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
//             GC.Collect();
//         }
        //
        // private static async Task SaveFile(string filename, bool suppressDebug = false)
        // {
        //     if (AppConstants.Data == null || AppConstants.Data.UnsupportedBytecodeVersion)
        //         return;
        //
        //     bool isDifferentPath = AppConstants.FilePath != filename;
        //
        //     LoaderDialogFactory.Create(Application.Current?.ApplicationLifetime as Window, true, "Saving", "Saving, please wait...");
        //     
        //     IProgress<Tuple<int, string>> progress = new Progress<Tuple<int, string>>(i => { LoaderDialogFactory.ReportProgress(i.Item2, i.Item1); });
        //     IProgress<double?> setMax = new Progress<double?>(i => { dialog.Maximum = i; });
        //     
        //     AppConstants.FilePath = filename;
        //     
        //     if (Path.GetDirectoryName(AppConstants.FilePath) != Path.GetDirectoryName(filename))
        //         CloseChildFiles();
        //
        //     // TODO DebugDataDialog.DebugDataMode debugMode = DebugDataDialog.DebugDataMode.NoDebug;
        //     if (!suppressDebug && AppConstants.Data.GeneralInfo != null && !AppConstants.Data.GeneralInfo.IsDebuggerDisabled)
        //         Application.Current.ShowWarning("You are saving the game in GameMaker Studio debug mode. Unless the debugger is running, the normal runtime will simply hang after loading. You can turn this off in General Info by checking the \"Disable Debugger\" box and saving.", "GMS Debugger");
        //     Task t = Task.Run(async () =>
        //     {
        //         bool SaveSucceeded = true;
        //
        //         try
        //         {
        //             using (var stream = new FileStream(filename + "temp", FileMode.Create, FileAccess.Write))
        //             {
        //                 UndertaleIO.Write(stream, AppConstants.Data, message =>
        //                 {
        //                     FileMessageEvent?.Invoke(message);
        //                 });
        //             }
        //
        //             QoiConverter.ClearSharedBuffer();
        //
        //             if (debugMode != DebugDataDialog.DebugDataMode.NoDebug)
        //             {
        //                 FileMessageEvent?.Invoke("Generating debugger data...");
        //
        //                 UndertaleDebugData debugData = UndertaleDebugData.CreateNew();
        //
        //                 setMax.Report(AppConstants.Data.Code.Count);
        //                 int count = 0;
        //                 object countLock = new object();
        //                 string[] outputs = new string[AppConstants.Data.Code.Count];
        //                 UndertaleDebugInfo[] outputsOffsets = new UndertaleDebugInfo[AppConstants.Data.Code.Count];
        //                 GlobalDecompileContext context = new GlobalDecompileContext(AppConstants.Data, false);
        //                 Parallel.For(0, AppConstants.Data.Code.Count, (i) =>
        //                 {
        //                     var code = AppConstants.Data.Code[i];
        //
        //                     if (debugMode == DebugDataDialog.DebugDataMode.Decompiled)
        //                     {
        //                         //Debug.WriteLine("Decompiling " + code.Name.Content);
        //                         string output;
        //                         try
        //                         {
        //                             output = Decompiler.Decompile(code, context);
        //                         }
        //                         catch (Exception e)
        //                         {
        //                             Debug.WriteLine(e.Message);
        //                             output = "/*\nEXCEPTION!\n" + e.ToString() + "\n*/";
        //                         }
        //                         outputs[i] = output;
        //
        //                         UndertaleDebugInfo debugInfo = new UndertaleDebugInfo();
        //                         debugInfo.Add(new UndertaleDebugInfo.DebugInfoPair() { SourceCodeOffset = 0, BytecodeOffset = 0 }); // TODO: generate this too! :D
        //                         outputsOffsets[i] = debugInfo;
        //                     }
        //                     else
        //                     {
        //                         StringBuilder sb = new StringBuilder();
        //                         UndertaleDebugInfo debugInfo = new UndertaleDebugInfo();
        //
        //                         foreach (var instr in code.Instructions)
        //                         {
        //                             if (debugMode == DebugDataDialog.DebugDataMode.FullAssembler || instr.Kind == UndertaleInstruction.Opcode.Pop || instr.Kind == UndertaleInstruction.Opcode.Popz || instr.Kind == UndertaleInstruction.Opcode.B || instr.Kind == UndertaleInstruction.Opcode.Bt || instr.Kind == UndertaleInstruction.Opcode.Bf || instr.Kind == UndertaleInstruction.Opcode.Ret || instr.Kind == UndertaleInstruction.Opcode.Exit)
        //                                 debugInfo.Add(new UndertaleDebugInfo.DebugInfoPair() { SourceCodeOffset = (uint)sb.Length, BytecodeOffset = instr.Address * 4 });
        //                             instr.ToString(sb, code);
        //                             sb.Append('\n');
        //                         }
        //                         outputs[i] = sb.ToString();
        //                         outputsOffsets[i] = debugInfo;
        //                     }
        //
        //                     lock (countLock)
        //                     {
        //                         progress.Report(new Tuple<int, string>(++count, code.Name.Content));
        //                     }
        //                 });
        //                 setMax.Report(null);
        //
        //                 for (int i = 0; i < AppConstants.Data.Code.Count; i++)
        //                 {
        //                     debugData.SourceCode.Add(new UndertaleScriptSource() { SourceCode = debugData.Strings.MakeString(outputs[i]) });
        //                     debugData.DebugInfo.Add(outputsOffsets[i]);
        //                     debugData.LocalVars.Add(AppConstants.Data.CodeLocals[i]);
        //                     if (debugData.Strings.IndexOf(AppConstants.Data.CodeLocals[i].Name) < 0)
        //                         debugData.Strings.Add(AppConstants.Data.CodeLocals[i].Name);
        //                     foreach (var local in AppConstants.Data.CodeLocals[i].Locals)
        //                         if (debugData.Strings.IndexOf(local.Name) < 0)
        //                             debugData.Strings.Add(local.Name);
        //                 }
        //
        //                 using (UndertaleWriter writer = new UndertaleWriter(new FileStream(Path.ChangeExtension(FilePath, ".yydebug"), FileMode.Create, FileAccess.Write)))
        //                 {
        //                     debugData.FORM.Serialize(writer);
        //                     writer.ThrowIfUnwrittenObjects();
        //                     writer.Flush();
        //                 }
        //             }
        //         }
        //         catch (Exception e)
        //         {
        //             if (!UndertaleIO.IsDictionaryCleared)
        //             {
        //                 try
        //                 {
        //                     var listChunks = AppConstants.Data.FORM.Chunks.Values.Select(x => x as IUndertaleListChunk);
        //                     Parallel.ForEach(listChunks.Where(x => x is not null), (chunk) =>
        //                     {
        //                         chunk.ClearIndexDict();
        //                     });
        //
        //                     UndertaleIO.IsDictionaryCleared = true;
        //                 }
        //                 catch { }
        //             }
        //
        //             Dispatcher.Invoke(() =>
        //             {
        //                 this.ShowError("An error occured while trying to save:\n" + e.Message, "Save error");
        //             });
        //
        //             SaveSucceeded = false;
        //         }
        //         // Don't make any changes unless the save succeeds.
        //         try
        //         {
        //             if (SaveSucceeded)
        //             {
        //                 // It saved successfully!
        //                 // If we're overwriting a previously existing data file, we're going to delete it now.
        //                 // Then, we're renaming it back to the proper (non-temp) file name.
        //                 if (File.Exists(filename))
        //                     File.Delete(filename);
        //                 File.Move(filename + "temp", filename);
        //
        //                 await SaveGMLCache(filename, true, dialog, isDifferentPath);
        //
        //                 // Also make the changes to the profile system.
        //                 await ProfileSaveEvent(AppConstants.Data, filename);
        //                 SaveTempToMainProfile();
        //             }
        //             else
        //             {
        //                 // It failed, but since we made a temp file for saving, no data was overwritten or destroyed (hopefully)
        //                 // We need to delete the temp file though (if it exists).
        //                 if (File.Exists(filename + "temp"))
        //                     File.Delete(filename + "temp");
        //                 // No profile system changes, since the save failed, like a save was never attempted.
        //             }
        //         }
        //         catch (Exception exc)
        //         {
        //             Dispatcher.Invoke(() =>
        //             {
        //                 this.ShowError("An error occured while trying to save:\n" + exc.Message, "Save error");
        //             });
        //
        //             SaveSucceeded = false;
        //         }
        //         if (AppConstants.Data != null)
        //         {
        //             AppConstants.Data.ToolInfo.ProfileMode = SettingsWindow.ProfileModeEnabled;
        //             AppConstants.Data.ToolInfo.CurrentMD5 = BitConverter.ToString(MD5CurrentlyLoaded).Replace("-", "").ToLowerInvariant();
        //         }
        //
        //         #pragma warning disable CA1416
        //         UndertaleCodeEditor.gettextJSON = null;
        //         #pragma warning restore CA1416
        //
        //         Dispatcher.Invoke(() =>
        //         {
        //             dialog.Hide();
        //         });
        //     });
        //     dialog.ShowDialog();
        //     await t;
        //
        //     GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
        //     GC.Collect();
        // }
        //
        public static Dictionary<string, NamedPipeServerStream> childFiles = new Dictionary<string, NamedPipeServerStream>();

        public static void OpenChildFile(string filename, string chunkName, int itemIndex)
        {
            if (childFiles.ContainsKey(filename))
            {
                try
                {
                    StreamWriter existingwriter = new StreamWriter(childFiles[filename]);
                    existingwriter.WriteLine(chunkName + ":" + itemIndex);
                    existingwriter.Flush();
                    return;
                }
                catch (IOException e)
                {
                    Debug.WriteLine(e);
                    childFiles.Remove(filename);
                }
            }

            string key = Guid.NewGuid().ToString();

            string dir = Path.GetDirectoryName(AppConstants.FilePath);
            Process.Start(Environment.ProcessPath, "\"" + Path.Combine(dir, filename) + "\" " + key);

            var server = new NamedPipeServerStream(key);
            server.WaitForConnection();
            childFiles.Add(filename, server);

            StreamWriter writer = new StreamWriter(childFiles[filename]);
            writer.WriteLine(chunkName + ":" + itemIndex);
            writer.Flush();
        }

        public static void CloseChildFiles()
        {
            foreach (var pair in childFiles)
            {
                pair.Value.Close();
            }
            childFiles.Clear();
        }
        
        public static async Task ListenChildConnection(string key)
        {
            var client = new NamedPipeClientStream(key);
            client.Connect();
            StreamReader reader = new StreamReader(client);

            while (true)
            {
                string[] thingToOpen = (await reader.ReadLineAsync()).Split(':');
                if (thingToOpen.Length != 2)
                    throw new Exception("ummmmm");
                if (thingToOpen[0] != "AUDO") // Just pretend I'm not hacking it together that poorly
                    throw new Exception("errrrr");
                // TODO OpenInTab(AppConstants.Data.EmbeddedAudio[Int32.Parse(thingToOpen[1])], false, "Embedded Audio");
                // Activate();
            }
        }
        
        // private static async void LoadGMLCache(string filename, LoaderDialogViewModel dialog = null)
        // {
        //     await Task.Run(() => {
        //         if (Settings.Instance.UseGMLCache)
        //         {
        //             string cacheDirPath = Path.Combine(ExePath, "GMLCache");
        //             string cacheIndexPath = Path.Combine(cacheDirPath, "index");
        //
        //             if (!File.Exists(cacheIndexPath))
        //                 return;
        //
        //             dialog?.Dispatcher.Invoke(() => dialog.ReportProgress("Loading decompiled code cache..."));
        //
        //             string[] indexLines = File.ReadAllLines(cacheIndexPath);
        //
        //             int num = -1;
        //             for (int i = 0; i < indexLines.Length; i++)
        //                 if (indexLines[i] == filename)
        //                 {
        //                     num = i;
        //                     break;
        //                 }
        //
        //             if (num == -1)
        //                 return;
        //
        //             if (!File.Exists(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 this.ShowWarning("Decompiled code cache file for open data is missing, but its name present in the index.");
        //
        //                 return;
        //             }
        //
        //             string hash = GenerateMD5(filename);
        //
        //             using (StreamReader fs = new(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 string prevHash = fs.ReadLine();
        //
        //                 if (!Regex.IsMatch(prevHash, "^[0-9a-fA-F]{32}$")) //if first 32 bytes of cache file are not a valid MD5
        //                     this.ShowWarning("Decompiled code cache for open file is broken.\nThe cache will be generated again.");
        //                 else
        //                 {
        //                     if (hash == prevHash)
        //                     {
        //                         string cacheStr = fs.ReadLine();
        //                         string failedStr = fs.ReadLine();
        //
        //                         try
        //                         {
        //                             AppConstants.Data.GMLCache = SystemJson.JsonSerializer.Deserialize<ConcurrentDictionary<string, string>>(cacheStr);
        //
        //                             if (failedStr is not null)
        //                                 AppConstants.Data.GMLCacheFailed = SystemJson.JsonSerializer.Deserialize<List<string>>(failedStr);
        //                             else
        //                                 AppConstants.Data.GMLCacheFailed = new();
        //                         }
        //                         catch
        //                         {
        //                             this.ShowWarning("Decompiled code cache for open file is broken.\nThe cache will be generated again.");
        //
        //                             AppConstants.Data.GMLCache = null;
        //                             AppConstants.Data.GMLCacheFailed = null;
        //
        //                             return;
        //                         }
        //
        //                         string[] codeNames = AppConstants.Data.Code.Where(x => x.ParentEntry is null).Select(x => x.Name.Content).ToArray();
        //                         string[] invalidNames = AppConstants.Data.GMLCache.Keys.Except(codeNames).ToArray();
        //                         if (invalidNames.Length > 0)
        //                         {
        //                             this.ShowWarning($"Decompiled code cache for open file contains one or more non-existent code names (first - \"{invalidNames[0]}\").\nThe cache will be generated again.");
        //
        //                             AppConstants.Data.GMLCache = null;
        //
        //                             return;
        //                         }
        //
        //                         AppConstants.Data.GMLCacheChanged = new();
        //                         AppConstants.Data.GMLEditedBefore = new();
        //                         AppConstants.Data.GMLCacheWasSaved = true;
        //                     }
        //                     else
        //                         this.ShowWarning("Open file differs from the one the cache was generated for.\nThat decompiled code cache will be generated again.");
        //                 }
        //             }
        //         }
        //     });
        // }
        // private static async void SaveGMLCache(string filename, bool updateCache = true, LoaderDialogViewModel dialog = null, bool isDifferentPath = false)
        // {
        //     await Task.Run(async () => {
        //         if (Settings.Instance.UseGMLCache && AppConstants.Data?.GMLCache?.Count > 0 && AppConstants.Data.GMLCacheIsReady && (isDifferentPath || !AppConstants.Data.GMLCacheWasSaved || !AppConstants.Data.GMLCacheChanged.IsEmpty))
        //         {
        //             Dispatcher.UIThread.Invoke(() => dialog.ReportProgress("Saving decompiled code cache..."));
        //
        //             string cacheDirPath = Path.Combine(ExePath, "GMLCache");
        //             string cacheIndexPath = Path.Combine(cacheDirPath, "index");
        //             if (!File.Exists(cacheIndexPath))
        //             {
        //                 Directory.CreateDirectory(cacheDirPath);
        //                 File.WriteAllText(cacheIndexPath, filename);
        //             }
        //
        //             List<string> indexLines = File.ReadAllLines(cacheIndexPath).ToList();
        //
        //             int num = -1;
        //             for (int i = 0; i < indexLines.Count; i++)
        //                 if (indexLines[i] == filename)
        //                 {
        //                     num = i;
        //                     break;
        //                 }
        //
        //             if (num == -1) //if it's new cache file
        //             {
        //                 num = indexLines.Count;
        //
        //                 indexLines.Add(filename);
        //             }
        //
        //             if (updateCache)
        //             {
        //                 await GenerateGMLCache(null, dialog, true);
        //                 await LoaderDialogFactory.StopProgressBarUpdater();
        //             }
        //
        //             string[] codeNames = AppConstants.Data.Code.Where(x => x.ParentEntry is null).Select(x => x.Name.Content).ToArray();
        //             Dictionary<string, string> sortedCache = new(AppConstants.Data.GMLCache.OrderBy(x => Array.IndexOf(codeNames, x.Key)));
        //             AppConstants.Data.GMLCacheFailed = AppConstants.Data.GMLCacheFailed.OrderBy(x => Array.IndexOf(codeNames, x)).ToList();
        //
        //             if (!updateCache && AppConstants.Data.GMLEditedBefore.Count > 0) //if saving the original cache
        //                 foreach (string name in AppConstants.Data.GMLEditedBefore)
        //                     sortedCache.Remove(name);                   //exclude the code that was edited from the save list
        //
        //             Dispatcher.UIThread.Invoke(() => dialog.ReportProgress("Saving decompiled code cache..."));
        //
        //             string hash = GenerateMD5(filename);
        //
        //             using (FileStream fs = File.Create(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 fs.Write(Encoding.UTF8.GetBytes(hash + '\n'));
        //                 fs.Write(SystemJson.JsonSerializer.SerializeToUtf8Bytes(sortedCache));
        //
        //                 if (AppConstants.Data.GMLCacheFailed.Count > 0)
        //                 {
        //                     fs.WriteByte((byte)'\n');
        //                     fs.Write(SystemJson.JsonSerializer.SerializeToUtf8Bytes(AppConstants.Data.GMLCacheFailed));
        //                 }
        //             }
        //
        //             File.WriteAllLines(cacheIndexPath, indexLines);
        //
        //             AppConstants.Data.GMLCacheWasSaved = true;
        //         }
        //     });
        // }

        // public static async Task<bool> GenerateGMLCache(ThreadLocal<GlobalDecompileContext> decompileContext = null, object dialog = null, bool clearGMLEditedBefore = false)
        // {
        //     if (!Settings.Instance.UseGMLCache)
        //         return false;
        //
        //     bool createdDialog = false;
        //     bool existedDialog = false;
        //     AppConstants.Data.GMLCacheIsReady = false;
        //
        //     if (AppConstants.Data.GMLCache is null)
        //         AppConstants.Data.GMLCache = new();
        //
        //     ConcurrentBag<string> failedBag = new();
        //
        //     if (scriptDialog is null)
        //     {
        //         if (dialog is null)
        //         {
        //             Dispatcher.Invoke(() =>
        //             {
        //                 scriptDialog = new LoaderDialog("Script in progress...", "Please wait...")
        //                 {
        //                     Owner = this,
        //                     PreventClose = true
        //                 };
        //             });
        //
        //             createdDialog = true;
        //         }
        //         else
        //             scriptDialog = dialog as LoaderDialog;
        //     }
        //     else
        //         existedDialog = true;
        //
        //     if (decompileContext is null)
        //         decompileContext = new(() => new GlobalDecompileContext(AppConstants.Data, false));
        //
        //     if (AppConstants.Data.KnownSubFunctions is null) //if we run script before opening any code
        //     {
        //         SetProgressBar(null, "Building the cache of all sub-functions...", 0, 0);
        //         await Task.Run(() => Decompiler.BuildSubFunctionCache(AppConstants.Data));
        //     }
        //
        //     if (AppConstants.Data.GMLCache.IsEmpty)
        //     {
        //         SetProgressBar(null, "Generating decompiled code cache...", 0, AppConstants.Data.Code.Count);
        //         StartProgressBarUpdater();
        //
        //         await Task.Run(() => Parallel.ForEach(AppConstants.Data.Code, (code) =>
        //         {
        //             if (code is not null && code.ParentEntry is null)
        //             {
        //                 try
        //                 {
        //                     AppConstants.Data.GMLCache[code.Name.Content] = Decompiler.Decompile(code, decompileContext.Value);
        //                 }
        //                 catch
        //                 {
        //                     failedBag.Add(code.Name.Content);
        //                 }
        //             }
        //
        //             IncrementProgressParallel();
        //         }));
        //
        //         AppConstants.Data.GMLEditedBefore = new(AppConstants.Data.GMLCacheChanged);
        //         AppConstants.Data.GMLCacheChanged.Clear();
        //         AppConstants.Data.GMLCacheFailed = failedBag.ToList();
        //     }
        //     else
        //     {
        //         List<string> codeToUpdate;
        //         bool cacheIsFull = !(AppConstants.Data.GMLCache.Count < AppConstants.Data.Code.Where(x => x.ParentEntry is null).Count() - AppConstants.Data.GMLCacheFailed.Count);
        //
        //         if (cacheIsFull)
        //         {
        //             AppConstants.Data.GMLCacheChanged = new(AppConstants.Data.GMLCacheChanged.Distinct()); //remove duplicates
        //
        //             codeToUpdate = AppConstants.Data.GMLCacheChanged.ToList();
        //         }
        //         else
        //         {
        //             //add missing and modified code cache names to the update list (and remove duplicates)
        //             codeToUpdate = AppConstants.Data.GMLCacheChanged.Union(
        //                 AppConstants.Data.Code.Where(x => x.ParentEntry is null)
        //                          .Select(x => x.Name.Content)
        //                          .Except(AppConstants.Data.GMLCache.Keys)
        //                          .Except(AppConstants.Data.GMLCacheFailed))
        //                 .ToList();
        //         }
        //
        //         if (codeToUpdate.Count > 0)
        //         {
        //             SetProgressBar(null, "Updating decompiled code cache...", 0, codeToUpdate.Count);
        //             StartProgressBarUpdater();
        //
        //             await Task.Run(() => Parallel.ForEach(codeToUpdate.Select(x => AppConstants.Data.Code.ByName(x)), (code) =>
        //             {
        //                 if (code is not null && code.ParentEntry is null)
        //                 {
        //                     try
        //                     {
        //                         AppConstants.Data.GMLCache[code.Name.Content] = Decompiler.Decompile(code, decompileContext.Value);
        //
        //                         AppConstants.Data.GMLCacheFailed.Remove(code.Name.Content); //that code compiles now
        //                     }
        //                     catch
        //                     {
        //                         failedBag.Add(code.Name.Content);
        //                     }
        //                 }
        //
        //                 IncrementProgressParallel();
        //             }));
        //
        //             if (clearGMLEditedBefore)
        //                 AppConstants.Data.GMLEditedBefore.Clear();
        //             else
        //                 AppConstants.Data.GMLEditedBefore = AppConstants.Data.GMLEditedBefore.Union(AppConstants.Data.GMLCacheChanged).ToList();
        //
        //             AppConstants.Data.GMLCacheChanged.Clear();
        //             AppConstants.Data.GMLCacheFailed = AppConstants.Data.GMLCacheFailed.Union(failedBag).ToList();
        //             AppConstants.Data.GMLCacheWasSaved = false;
        //         }
        //         else if (clearGMLEditedBefore)
        //             AppConstants.Data.GMLEditedBefore.Clear();
        //
        //         if (!existedDialog)
        //             scriptDialog = null;
        //
        //         if (createdDialog)
        //         {
        //             await StopProgressBarUpdater();
        //             HideProgressBar();
        //         }
        //     }
        //
        //     AppConstants.Data.GMLCacheIsReady = true;
        //
        //     return true;
        // }
        
        
        // This is the external method p/invoke for registering the mod tool in Windows as the program to open data.wim files for Undertale.
        [DllImport("shell32.dll")]
        static extern void SHChangeNotify(long wEventId, uint uFlags, IntPtr dwItem1, IntPtr dwItem2);
        const long SHCNE_ASSOCCHANGED = 0x08000000;
        
        public static readonly string[] IFF_EXTENSIONS = new string[] { ".win", ".unx", ".ios", ".droid", ".3ds", ".symbian" };
        
        public static async void Startup()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                try
                {
                    string procFileName = Environment.ProcessPath;
                    var HKCU_Classes = Registry.CurrentUser.OpenSubKey(@"Software\Classes", true);
                    var UndertaleModTool_app = HKCU_Classes.CreateSubKey(@"UndertaleModTool");

                    UndertaleModTool_app.SetValue("", "UndertaleModTool");
                    UndertaleModTool_app.CreateSubKey(@"shell\open\command").SetValue("", "\"" + procFileName + "\" \"%1\"", RegistryValueKind.String);
                    UndertaleModTool_app.CreateSubKey(@"shell\launch\command").SetValue("", "\"" + procFileName + "\" \"%1\" launch", RegistryValueKind.String);
                    UndertaleModTool_app.CreateSubKey(@"shell\launch").SetValue("", "Run game normally", RegistryValueKind.String);
                    UndertaleModTool_app.CreateSubKey(@"shell\special_launch\command").SetValue("", "\"" + procFileName + "\" \"%1\" special_launch", RegistryValueKind.String);
                    UndertaleModTool_app.CreateSubKey(@"shell\special_launch").SetValue("", "Run extended options", RegistryValueKind.String);

                    if (File.Exists("dna.txt"))
                    {
                        ScriptMessages.ScriptMessage("Opt out detected.");
                        Settings.Instance.AutomaticFileAssociation = false;
                        Settings.Save();
                    }
                    if (Settings.Instance.AutomaticFileAssociation)
                    {
                        foreach (var extStr in IFF_EXTENSIONS)
                        {
                            var ext = HKCU_Classes.CreateSubKey(extStr);
                            ext.SetValue("", "UndertaleModTool", RegistryValueKind.String);
                        }
                        SHChangeNotify(SHCNE_ASSOCCHANGED, 0, IntPtr.Zero, IntPtr.Zero);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(ex.ToString());
                }
            }

            // var args = Environment.GetCommandLineArgs();
            // bool isLaunch = false;
            // bool isSpecialLaunch = false;
            // if (args.Length > 1)
            // {
            //     if (args.Length > 2)
            //     {
            //         isLaunch = args[2] == "launch";
            //         isSpecialLaunch = args[2] == "special_launch";
            //     }
            //
            //     string arg = args[1];
            //     if (File.Exists(arg))
            //     {
            //         await LoadFile(arg, true, isLaunch || isSpecialLaunch);
            //     }
            //     else if (arg == "deleteTempFolder") // if was launched from UndertaleModToolUpdater
            //     {
            //         _ = Task.Run(() =>
            //         {
            //             Process[] updaterInstances = Process.GetProcessesByName("UndertaleModToolUpdater");
            //             bool updaterClosed = false;
            //
            //             if (updaterInstances.Length > 0)
            //             {
            //                 foreach (Process instance in updaterInstances)
            //                 {
            //                     if (!instance.WaitForExit(5000))
            //                         Application.Current.ShowWarning("UndertaleModToolUpdater app didn't exit.\nCan't delete its temp folder.");
            //                     else
            //                         updaterClosed = true;
            //                 }
            //             }
            //             else
            //                 updaterClosed = true;
            //
            //             if (updaterClosed)
            //             {
            //                 bool deleted = false;
            //                 string exMessage = "(error message is missing)";
            //                 string tempFolder = Path.Combine(Path.GetTempPath(), "UndertaleModTool");
            //
            //                 for (int i = 0; i <= 5; i++)
            //                 {
            //                     try
            //                     {
            //                         Directory.Delete(tempFolder, true);
            //
            //                         deleted = true;
            //                         break;
            //                     }
            //                     catch (Exception ex)
            //                     {
            //                         exMessage = ex.Message;
            //                     }
            //
            //                     Thread.Sleep(1000);
            //                 }
            //
            //                 if (!deleted)
            //                     Application.Current.ShowWarning($"The updater temp folder can't be deleted.\nError - {exMessage}.");
            //             }
            //         });
            //     }
            //
            //     if (isSpecialLaunch)
            //     {
            //         RuntimePicker picker = new RuntimePicker();
            //         picker.Owner = this;
            //         var runtime = picker.Pick(AppConstants.FilePath, AppConstants.Data);
            //         if (runtime == null)
            //             return;
            //         Process.Start(runtime.Path, "-game \"" + AppConstants.FilePath + "\"");
            //         Environment.Exit(0);
            //     }
            //     else if (isLaunch)
            //     {
            //         string gameExeName = AppConstants.Data?.GeneralInfo?.FileName?.Content;
            //         if (gameExeName == null || AppConstants.FilePath == null)
            //         {
            //             ScriptMessages.ScriptError("Null game executable name or location");
            //             Environment.Exit(0);
            //         }
            //         string gameExePath = Path.Combine(Path.GetDirectoryName(AppConstants.FilePath), gameExeName + ".exe");
            //         if (!File.Exists(gameExePath))
            //         {
            //             ScriptMessages.ScriptError("Cannot find game executable path, expected: " + gameExePath);
            //             Environment.Exit(0);
            //         }
            //         if (!File.Exists(AppConstants.FilePath))
            //         {
            //             ScriptMessages.ScriptError("Cannot find data file path, expected: " + AppConstants.FilePath);
            //             Environment.Exit(0);
            //         }
            //         if (gameExeName != null)
            //             Process.Start(gameExePath, "-game \"" + AppConstants.FilePath + "\" -debugoutput \"" + Path.ChangeExtension(AppConstants.FilePath, ".gamelog.txt") + "\"");
            //         Environment.Exit(0);
            //     }
            //     else if (args.Length > 2)
            //     {
            //         _ = ListenChildConnection(args[2]);
            //     }
            // }

            // Copy the known code corrections into the profile, if they don't already exist.
            // ApplyCorrections();
            // CrashCheck();

            // RunGMSDebuggerItem.Visibility = ShowDebuggerOption ? Visibility.Visible : Visibility.Collapsed;
        }
    }
}


====================================================================
FILE: ./ViewLocator.cs
====================================================================

using System;
using Avalonia.Controls;
using Avalonia.Controls.Templates;
using UndertaleModToolAvalonia.ViewModels;

namespace UndertaleModToolAvalonia;

public class ViewLocator : IDataTemplate
{
    public Control? Build(object? data)
    {
        if (data is null)
            return null;

        var name = data.GetType().FullName!.Replace("ViewModel", "View", StringComparison.Ordinal);
        var type = Type.GetType(name);

        if (type != null)
        {
            var control = (Control)Activator.CreateInstance(type)!;
            control.DataContext = data;
            return control;
        }

        return new TextBlock { Text = "Not Found: " + name };
    }

    public bool Match(object? data)
    {
        return data is ViewModelBase;
    }
}

====================================================================
FILE: ./ViewModels/EditorViewModels/EditorViewModel.cs
====================================================================

﻿using Avalonia.Controls;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using UndertaleModLib;
using UndertaleModToolAvalonia.Views.EditorViews;
using CommunityToolkit.Mvvm.ComponentModel;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Scripting;
using Newtonsoft.Json;
using UndertaleModToolAvalonia.Converters;
using UndertaleModToolAvalonia.Models.EditorModels;

namespace UndertaleModToolAvalonia.ViewModels.EditorViewModels
{
    public partial class EditorViewModel : ViewModelBase
    {
        [ObservableProperty] private int currentTabIndex = 0;

        [ObservableProperty] private object highlighted;

        public object Selected
        {
            get => null;// TODO Implement CurrentTab?.CurrentObject;
            set
            {
                OnPropertyChanged();
                // TODO Implement OpenInTab(value);
            } 
        }
        
        [ObservableProperty] private bool wasWarnedAboutTempRun = false;
        
        [ObservableProperty] private bool finishedMessageEnabled = true;
        
        [ObservableProperty] private bool scriptExecutionSuccess = true;
        
        [ObservableProperty] private bool isSaving = false;
        
        [ObservableProperty] private string scriptErrorMessage = "";
        
        [ObservableProperty] private string scriptErrorType = "";
        
        public enum SaveResult
        {
            NotSaved,
            Saved,
            Error
        }
        public enum ScrollDirection
        {
            Left,
            Right
        }
        
        private int progressValue;
        private Task updater;
        private CancellationTokenSource cts;
        private CancellationToken cToken;
        private readonly object bindingLock = new();
        private HashSet<string> syncBindings = new();
        [ObservableProperty] private bool roomRendererEnabled;

        partial void OnRoomRendererEnabledChanged(bool value)
        {
            // TODO Add Avalonia implementation.
            // if (UndertaleRoomRenderer.RoomRendererTemplate is null)
            //     UndertaleRoomRenderer.RoomRendererTemplate = (DataTemplate)DataEditor.FindResource("roomRendererTemplate");

            if (value)
            {
                // DataEditor.ContentTemplate = UndertaleRoomRenderer.RoomRendererTemplate;
                UndertaleCachedImageLoader.ReuseTileBuffer = true;
            }
            else
            {
                // DataEditor.ContentTemplate = null;
                // CurrentTab.CurrentObject = LastOpenedObject;
                // LastOpenedObject = null;
                UndertaleCachedImageLoader.Reset();
                // CachedTileDataLoader.Reset();
            }
        }

        [ObservableProperty] private object lastOpenedObject; // for restoring the object that was opened before room rendering
        
        [ObservableProperty] private bool lsAppClosed = false;
        
        private HttpClient httpClient;
        
        private LoaderDialogView scriptDialog;
        
        public static string AppDataFolder => Settings.AppDataFolder;
        public static string ProfilesFolder = Path.Combine(Settings.AppDataFolder, "Profiles");
        public static string CorrectionsFolder = Path.Combine(Program.GetExecutableDirectory(), "Corrections");
        public string ProfileHash = "Unknown";
        public bool CrashedWhileEditing = false;

        // Scripting interface-related
        private ScriptOptions scriptOptions;
        private Task scriptSetupTask;
        
        [ObservableProperty] private string objectLabel  = string.Empty;
        
        // TODO Not sure if I can just use Avalonia's theme system.
        // private static readonly Color darkColor = Color.FromArgb(255, 32, 32, 32);
        // private static readonly Color darkLightColor = Color.FromArgb(255, 48, 48, 48);
        // private static readonly Color whiteColor = Color.FromArgb(255, 222, 222, 222);
        // private static readonly SolidColorBrush grayTextBrush = new(Color.FromArgb(255, 179, 179, 179));
        // private static readonly SolidColorBrush inactiveSelectionBrush = new(Color.FromArgb(255, 212, 212, 212));
        // private static readonly Dictionary<ResourceKey, object> appDarkStyle = new()
        // {
        //     { SystemColors.WindowTextBrushKey, new SolidColorBrush(whiteColor) },
        //     { SystemColors.ControlTextBrushKey, new SolidColorBrush(whiteColor) },
        //     { SystemColors.WindowBrushKey, new SolidColorBrush(darkColor) },
        //     { SystemColors.ControlBrushKey, new SolidColorBrush(darkLightColor) },
        //     { SystemColors.ControlLightBrushKey, new SolidColorBrush(Color.FromArgb(255, 60, 60, 60)) },
        //     { SystemColors.MenuTextBrushKey, new SolidColorBrush(whiteColor) },
        //     { SystemColors.MenuBrushKey, new SolidColorBrush(darkLightColor) },
        //     { SystemColors.GrayTextBrushKey, new SolidColorBrush(Color.FromArgb(255, 136, 136, 136)) },
        //     { SystemColors.InactiveSelectionHighlightBrushKey, new SolidColorBrush(Color.FromArgb(255, 112, 112, 112)) }
        // };

        public EditorViewModel()
        {
            Highlighted = new Description("Welcome to UndertaleModTool!", "Open a data.win file to get started, then double click on the items on the left to view them.");
            // TODO Implement OpenInTab(Highlighted);

            _ = new Settings();

            Settings.Instance.CanSave = false;
            Settings.Instance.CanSafelySave = false;

            scriptSetupTask = Task.Run(() =>
            {
                scriptOptions = ScriptOptions.Default
                    .AddImports("UndertaleModLib", "UndertaleModLib.Models", "UndertaleModLib.Decompiler",
                        "UndertaleModLib.Scripting", "UndertaleModLib.Compiler",
                        "UndertaleModToolAvalonia", "System", "System.IO", "System.Collections.Generic",
                        "System.Text.RegularExpressions")
                    .AddReferences(typeof(UndertaleObject).GetTypeInfo().Assembly,
                        GetType().GetTypeInfo().Assembly,
                        typeof(JsonConvert).GetTypeInfo().Assembly,
                        typeof(System.Text.RegularExpressions.Regex).GetTypeInfo().Assembly)
                    .WithEmitDebugInformation(true); //when script throws an exception, add an exception location (line number)
            });

            // TODO Same thing about Avalonia theme system.
            // var resources = Application.Current.Resources;
            // resources["CustomTextBrush"] = SystemColors.ControlTextBrush;
            // resources[SystemColors.GrayTextBrushKey] = grayTextBrush;
            // resources[SystemColors.InactiveSelectionHighlightBrushKey] = inactiveSelectionBrush;
        }
        
        
        
        
        
        
        
        
        

        
        private readonly Window perent;

        public EditorViewModel(Window perent)
        {
            this.perent = perent;
        }

        // [RelayCommand]
        // public async Task<bool> SaveDialog(bool suppressDebug = false)
        // {
        //     SaveFileDialog dlg = new SaveFileDialog();
        //     dlg.DefaultExtension = "wim";
        //     List<FileDialogFilter> filters = new List<FileDialogFilter>();
        //     FileDialogFilter AllFilter = new FileDialogFilter();
        //     AllFilter.Name = "All files";
        //     List<string> all = new List<string>();
        //     all.Add("*");
        //     AllFilter.Extensions = all;
        //     FileDialogFilter fileFilter = new FileDialogFilter();
        //     fileFilter.Name = "Game Maker Studio data files (.win, .unx, .ios, .droid, audiogroup*.dat)||*";
        //     List<string> ext = new List<string>();
        //     ext.Add("*.win");
        //     ext.Add("*.unx");
        //     ext.Add("*.ios");
        //     ext.Add("*.droid");
        //     ext.Add("audiogroup*.dat");
        //     fileFilter.Extensions = ext;
        //     filters.Add(fileFilter);
        //
        //     dlg.Filters = filters;
        //     dlg.Directory = AppConstants.LOCATION;
        //     string? file = await dlg.ShowAsync(perent);
        //     if (file != null)
        //     {
        //         await SaveFile(file, suppressDebug);
        //         return true;
        //     }
        //     return false;
        // }
        //
        // [RelayCommand]
        // public async Task<bool> OpenDialog()
        // {
        //     
        //     OpenFileDialog dlg = new OpenFileDialog();
        //     dlg.AllowMultiple = false;
        //     List<FileDialogFilter> filters = new List<FileDialogFilter>();
        //     FileDialogFilter AllFilter = new FileDialogFilter();
        //     AllFilter.Name = "All files";
        //     List<string> all = new List<string>();
        //     all.Add("");
        //     AllFilter.Extensions = all;
        //     FileDialogFilter fileFilter = new FileDialogFilter();
        //     fileFilter.Name = "Game Maker Studio data files (.win, .unx, .ios, .droid, audiogroup*.dat)";
        //     List<string> ext = new List<string>();
        //     ext.Add("win");
        //     ext.Add("unx");
        //     ext.Add("ios");
        //     ext.Add("droid");
        //     ext.Add("audiogroup*.dat");
        //     fileFilter.Extensions = ext;
        //     filters.Add(fileFilter);
        //     filters.Add(AllFilter);
        //     dlg.Filters = filters;
        //     dlg.Directory = AppConstants.LOCATION;
        //     string[]? file = await dlg.ShowAsync(perent);
        //     if (file != null)
        //     {
        //         await LoadFile(file[0], true);
        //         return true;
        //     }
        //     return false;
        // }

        // public async Task<bool> GenerateGMLCache(ThreadLocal<GlobalDecompileContext> decompileContext = null, bool clearGMLEditedBefore = false)
        // {
        //     if (!ProfileViewModel.UseGMLCache)
        //         return false;
        //
        //     bool createdDialog = false;
        //     bool existedDialog = false;
        //     AppConstants.Data.GMLCacheIsReady = false;
        //
        //     if (AppConstants.Data.GMLCache is null)
        //         AppConstants.Data.GMLCache = new();
        //
        //     ConcurrentBag<string> failedBag = new();
        //
        //     if (!LoaderDialogFactory.Created)
        //     {
        //         await Avalonia.Threading.Dispatcher.UIThread.InvokeAsync(async () =>
        //         {
        //             await LoaderDialogFactory.Create(perent, true, "Script in progress...", "Please wait...");
        //             LoaderDialogFactory.HideProgressBar();
        //         });
        //     }
        //
        //     if (decompileContext is null)
        //         decompileContext = new(() => new GlobalDecompileContext(AppConstants.Data, false));
        //
        //     if (AppConstants.Data.KnownSubFunctions is null) //if we run script before opening any code
        //         Decompiler.BuildSubFunctionCache(AppConstants.Data);
        //
        //     if (AppConstants.Data.GMLCache.IsEmpty)
        //     {
        //         await LoaderDialogFactory.SetProgressBar(null, "Generating decompiled code cache...", 0, AppConstants.Data.Code.Count);
        //         LoaderDialogFactory.StartProgressBarUpdater();
        //
        //         await Task.Run(() => Parallel.ForEach(AppConstants.Data.Code, (code) =>
        //         {
        //             if (code is not null && code.ParentEntry is null)
        //             {
        //                 try
        //                 {
        //                     AppConstants.Data.GMLCache[code.Name.Content] = Decompiler.Decompile(code, decompileContext.Value);
        //                 }
        //                 catch
        //                 {
        //                     failedBag.Add(code.Name.Content);
        //                 }
        //             }
        //
        //             IncrementProgressParallel();
        //         }));
        //
        //         AppConstants.Data.GMLEditedBefore = new(AppConstants.Data.GMLCacheChanged);
        //         AppConstants.Data.GMLCacheChanged.Clear();
        //         AppConstants.Data.GMLCacheFailed = failedBag.ToList();
        //     }
        //     else
        //     {
        //         List<string> codeToUpdate;
        //         bool cacheIsFull = !(AppConstants.Data.GMLCache.Count < AppConstants.Data.Code.Where(x => x.ParentEntry is null).Count() - AppConstants.Data.GMLCacheFailed.Count);
        //
        //         if (cacheIsFull)
        //         {
        //             AppConstants.Data.GMLCacheChanged = new(AppConstants.Data.GMLCacheChanged.Distinct()); //remove duplicates
        //
        //             codeToUpdate = AppConstants.Data.GMLCacheChanged.ToList();
        //         }
        //         else
        //         {
        //             //add missing and modified code cache names to the update list (and remove duplicates)
        //             codeToUpdate = AppConstants.Data.GMLCacheChanged.Union(
        //                     AppConstants.Data.Code.Where(x => x.ParentEntry is null)
        //                          .Select(x => x.Name.Content)
        //                          .Except(AppConstants.Data.GMLCache.Keys)
        //                          .Except(AppConstants.Data.GMLCacheFailed))
        //                 .ToList();
        //         }
        //
        //         if (codeToUpdate.Count > 0)
        //         {
        //             await LoaderDialogFactory.SetProgressBar(null, "Updating decompiled code cache...", 0, codeToUpdate.Count);
        //             LoaderDialogFactory.StartProgressBarUpdater();
        //
        //             await Task.Run(() => Parallel.ForEach(codeToUpdate.Select(x => AppConstants.Data.Code.ByName(x)), (code) =>
        //             {
        //                 if (code is not null && code.ParentEntry is null)
        //                 {
        //                     try
        //                     {
        //                         AppConstants.Data.GMLCache[code.Name.Content] = Decompiler.Decompile(code, decompileContext.Value);
        //
        //                         AppConstants.Data.GMLCacheFailed.Remove(code.Name.Content); //that code compiles now
        //                     }
        //                     catch
        //                     {
        //                         failedBag.Add(code.Name.Content);
        //                     }
        //                 }
        //
        //                 IncrementProgressParallel();
        //             }));
        //
        //             if (clearGMLEditedBefore)
        //                 AppConstants.Data.GMLEditedBefore.Clear();
        //             else
        //                 AppConstants.Data.GMLEditedBefore = AppConstants.Data.GMLEditedBefore.Union(AppConstants.Data.GMLCacheChanged).ToList();
        //
        //             AppConstants.Data.GMLCacheChanged.Clear();
        //             AppConstants.Data.GMLCacheFailed = AppConstants.Data.GMLCacheFailed.Union(failedBag).ToList();
        //             AppConstants.Data.GMLCacheWasSaved = false;
        //         }
        //         else if (clearGMLEditedBefore)
        //             AppConstants.Data.GMLEditedBefore.Clear();
        //
        //         if (!existedDialog)
        //             LoaderDialogFactory.Dispose();
        //
        //         if (createdDialog)
        //         {
        //             await LoaderDialogFactory.StopProgressBarUpdater();
        //             LoaderDialogFactory.HideProgressBar();
        //         }
        //     }
        //
        //     AppConstants.Data.GMLCacheIsReady = true;
        //
        //     return true;
        // }
        //
        // private async Task LoadGMLCache(string filename)
        // {
        //     await Task.Run(async () => {
        //         if (ProfileViewModel.UseGMLCache)
        //         {
        //             string cacheDirPath = Path.Combine(ExePath, "GMLCache");
        //             string cacheIndexPath = Path.Combine(cacheDirPath, "index");
        //
        //             if (!File.Exists(cacheIndexPath))
        //                 return;
        //
        //             await Dispatcher.UIThread.InvokeAsync(async () => await LoaderDialogFactory.UpdateProgressStatus("Loading decompiled code cache..."));
        //
        //             string[] indexLines = File.ReadAllLines(cacheIndexPath);
        //
        //             int num = -1;
        //             for (int i = 0; i < indexLines.Length; i++)
        //                 if (indexLines[i] == filename)
        //                 {
        //                     num = i;
        //                     break;
        //                 }
        //
        //             if (num == -1)
        //                 return;
        //
        //             if (!File.Exists(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 Application.Current.ShowMessage("Decompiled code cache file for open data is missing, but its name present in the index.");
        //
        //                 return;
        //             }
        //
        //             string hash = MD5HashManager.GenerateMD5(filename);
        //
        //             using (StreamReader fs = new(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 string prevHash = fs.ReadLine();
        //
        //                 if (!Regex.IsMatch(prevHash, "^[0-9a-fA-F]{32}$")) //if first 32 bytes of cache file are not a valid MD5
        //                     Application.Current.ShowMessage("Decompiled code cache for open file is broken.\nThe cache will be generated again.");
        //                 else
        //                 {
        //                     if (hash == prevHash)
        //                     {
        //                         string cacheStr = fs.ReadLine();
        //                         string failedStr = fs.ReadLine();
        //
        //                         try
        //                         {
        //                             AppConstants.Data.GMLCache = SystemJson.JsonSerializer.Deserialize<ConcurrentDictionary<string, string>>(cacheStr);
        //
        //                             if (failedStr is not null)
        //                                 AppConstants.Data.GMLCacheFailed = SystemJson.JsonSerializer.Deserialize<List<string>>(failedStr);
        //                             else
        //                                 AppConstants.Data.GMLCacheFailed = new();
        //                         }
        //                         catch
        //                         {
        //                             Application.Current.ShowMessage("Decompiled code cache for open file is broken.\nThe cache will be generated again.");
        //
        //                             AppConstants.Data.GMLCache = null;
        //                             AppConstants.Data.GMLCacheFailed = null;
        //
        //                             return;
        //                         }
        //
        //                         string[] codeNames = AppConstants.Data.Code.Where(x => x.ParentEntry is null).Select(x => x.Name.Content).ToArray();
        //                         string[] invalidNames = AppConstants.Data.GMLCache.Keys.Except(codeNames).ToArray();
        //                         if (invalidNames.Length > 0)
        //                         {
        //                             Application.Current.ShowMessage($"Decompiled code cache for open file contains one or more non-existent code names (first - \"{invalidNames[0]}\").\nThe cache will be generated again.");
        //
        //                             AppConstants.Data.GMLCache = null;
        //
        //                             return;
        //                         }
        //
        //                         AppConstants.Data.GMLCacheChanged = new();
        //                         AppConstants.Data.GMLEditedBefore = new();
        //                         AppConstants.Data.GMLCacheWasSaved = true;
        //                     }
        //                     else
        //                         Application.Current.ShowMessage("Open file differs from the one the cache was generated for.\nThat decompiled code cache will be generated again.");
        //                 }
        //             }
        //         }
        //     });
        // }
        //
        // private async Task SaveGMLCache(string filename, bool updateCache = true, bool isDifferentPath = false)
        // {
        //     await Task.Run(async () =>
        //     {
        //         if (ProfileViewModel.UseGMLCache && AppConstants.Data?.GMLCache?.Count > 0 && AppConstants.Data.GMLCacheIsReady && (isDifferentPath || !AppConstants.Data.GMLCacheWasSaved || !AppConstants.Data.GMLCacheChanged.IsEmpty))
        //         {
        //             await Dispatcher.UIThread.InvokeAsync(() => LoaderDialogFactory.UpdateProgressStatus("Saving decompiled code cache..."));
        //
        //             string cacheDirPath = Path.Combine(ExePath, "GMLCache");
        //             string cacheIndexPath = Path.Combine(cacheDirPath, "index");
        //             if (!File.Exists(cacheIndexPath))
        //             {
        //                 Directory.CreateDirectory(cacheDirPath);
        //                 File.WriteAllText(cacheIndexPath, filename);
        //             }
        //
        //             List<string> indexLines = File.ReadAllLines(cacheIndexPath).ToList();
        //
        //             int num = -1;
        //             for (int i = 0; i < indexLines.Count; i++)
        //                 if (indexLines[i] == filename)
        //                 {
        //                     num = i;
        //                     break;
        //                 }
        //
        //             if (num == -1) //if it's new cache file
        //             {
        //                 num = indexLines.Count;
        //
        //                 indexLines.Add(filename);
        //             }
        //
        //             if (updateCache)
        //             {
        //                 await GenerateGMLCache(null, true);
        //                 await LoaderDialogFactory.StopProgressBarUpdater();
        //             }
        //
        //             string[] codeNames = AppConstants.Data.Code.Where(x => x.ParentEntry is null).Select(x => x.Name.Content).ToArray();
        //             Dictionary<string, string> sortedCache = new(AppConstants.Data.GMLCache.OrderBy(x => Array.IndexOf(codeNames, x.Key)));
        //             AppConstants.Data.GMLCacheFailed = AppConstants.Data.GMLCacheFailed.OrderBy(x => Array.IndexOf(codeNames, x)).ToList();
        //
        //             if (!updateCache && AppConstants.Data.GMLEditedBefore.Count > 0) //if saving the original cache
        //                 foreach (string name in AppConstants.Data.GMLEditedBefore)
        //                     sortedCache.Remove(name);                   //exclude the code that was edited from the save list
        //
        //             await Dispatcher.UIThread.InvokeAsync(() => LoaderDialogFactory.UpdateProgressStatus("Saving decompiled code cache..."));
        //
        //             string hash = MD5HashManager.GenerateMD5(filename);
        //
        //             using (FileStream fs = File.Create(Path.Combine(cacheDirPath, num.ToString())))
        //             {
        //                 fs.Write(Encoding.UTF8.GetBytes(hash + '\n'));
        //                 fs.Write(SystemJson.JsonSerializer.SerializeToUtf8Bytes(sortedCache));
        //
        //                 if (AppConstants.Data.GMLCacheFailed.Count > 0)
        //                 {
        //                     fs.WriteByte((byte)'\n');
        //                     fs.Write(SystemJson.JsonSerializer.SerializeToUtf8Bytes(AppConstants.Data.GMLCacheFailed));
        //                 }
        //             }
        //
        //             File.WriteAllLines(cacheIndexPath, indexLines);
        //
        //             AppConstants.Data.GMLCacheWasSaved = true;
        //         }
        //     });
        // }
        //
        // public void CreateUMTLastEdited(string filename)
        // {
        //     try
        //     {
        //         File.WriteAllText(Path.Combine(ProfilesFolder, "LastEdited.txt"), ProfileHash + "\n" + filename);
        //     }
        //     catch (Exception exc)
        //     {
        //         Application.Current.ShowMessage("CreateUMTLastEdited error! Send this to Grossley#2869 and make an issue on Github\n" + exc);
        //     }
        // }
        //
        // public void DestroyUMTLastEdited()
        // {
        //     try
        //     {
        //         string path = Path.Combine(ProfilesFolder, "LastEdited.txt");
        //         if (File.Exists(path))
        //             File.Delete(path);
        //     }
        //     catch (Exception exc)
        //     {
        //         Application.Current.ShowMessage("DestroyUMTLastEdited error! Send this to Grossley#2869 and make an issue on Github\n" + exc);
        //     }
        // }

        

        // private async Task LoadFile(string filename, bool preventClose = false)
        // {
        //     await LoaderDialogFactory.Create(perent, preventClose, "Loading", "Loading, please wait...");
        //     DisposeGameData();
        //     Task t = Task.Run(() =>
        //     {
        //         bool hadWarnings = false;
        //         UndertaleData data = null;
        //         try
        //         {
        //             using (var stream = new FileStream(filename, FileMode.Open, FileAccess.Read))
        //             {
        //                 data = UndertaleIO.Read(stream, warning =>
        //                 {
        //                     MessageBox.Show($"Loading warning\n{warning}", perent);
        //                     hadWarnings = true;
        //                 }, async message =>
        //                 {
        //                     await LoaderDialogFactory.UpdateProgressStatus(message);
        //                 });
        //             }
        //
        //             // UndertaleEmbeddedTexture.TexData.ClearSharedStream();
        //         }
        //         catch (Exception e)
        //         {
        //             MessageBox.Show("An error occured while trying to load:\n" + e.Message);
        //         }
        //
        //         Dispatcher.UIThread.InvokeAsync(async () =>
        //         {
        //             if (data != null)
        //             {
        //                 if (data.UnsupportedBytecodeVersion)
        //                 {
        //                     MessageBox.Show("Only bytecode versions 13 to 17 are supported for now, you are trying to load " + data.GeneralInfo.BytecodeVersion + ". A lot of code is disabled and will likely break something. Saving/exporting is disabled.");
        //                     CanSave = false;
        //                     CanSafelySave = false;
        //                 }
        //                 else if (hadWarnings)
        //                 {
        //                     MessageBox.Show("Warnings occurred during loading. Data loss will likely occur when trying to save!");
        //                     CanSave = true;
        //                     CanSafelySave = false;
        //                 }
        //                 else
        //                 {
        //                     CanSave = true;
        //                     CanSafelySave = true;
        //                     await UpdateProfile(data, filename);
        //                     if (data != null)
        //                     {
        //                         data.ToolInfo.ProfileMode = ProfileViewModel.ProfileModeEnabled;
        //                         data.ToolInfo.CurrentMD5 = BitConverter.ToString(MD5CurrentlyLoaded).Replace("-", "").ToLowerInvariant();
        //                     }
        //                 }
        //                 if (data.IsYYC())
        //                 {
        //                     MessageBox.Show("This game uses YYC (YoYo Compiler), which means the code is embedded into the game executable. This configuration is currently not fully supported; continue at your own risk.");
        //                 }
        //                 if (data.GeneralInfo != null)
        //                 {
        //                     if (!data.GeneralInfo.IsDebuggerDisabled)
        //                     {
        //                         MessageBox.Show("This game is set to run with the GameMaker Studio debugger and the normal runtime will simply hang after loading if the debugger is not running. You can turn this off in General Info by checking the \"Disable Debugger\" box and saving.");
        //                     }
        //                 }
        //                 if (Path.GetDirectoryName(FilePath) != Path.GetDirectoryName(filename))
        //                     CloseChildFiles();
        //
        //                 if (FilePath != filename)
        //                     await SaveGMLCache(FilePath, false);
        //
        //                 Data = data;
        //
        //                 await LoadGMLCache(filename);
        //                 UndertaleCachedImageLoader.Reset();
        //                 //                CachedTileDataLoader.Reset();
        //
        //                 //                Data.ToolInfo.AppDataProfiles = ProfilesFolder;
        //                 //                FilePath = filename;
        //                 //                OnPropertyChanged("Data");
        //                 //                OnPropertyChanged("FilePath");
        //                 //                OnPropertyChanged("IsGMS2");
        //
        //                 //                BackgroundsItemsList.Header = IsGMS2 == Visibility.Visible
        //                 //                                              ? "Tile sets"
        //                 //                                              : "Backgrounds & Tile sets";
        //
        //                 //#pragma warning disable CA1416
        //                 //                UndertaleCodeEditor.gettext = null;
        //                 //                UndertaleCodeEditor.gettextJSON = null;
        //                 //#pragma warning restore CA1416
        //             }
        //             LoaderDialogFactory.HideProgressBar();
        //         });
        //     });
        //     await t;
        //
        //     // Clear "GC holes" left in the memory in process of data unserializing
        //     // https://docs.microsoft.com/en-us/dotnet/api/system.runtime.gcsettings.largeobjectheapcompactionmode?view=net-6.0
        //     GCSettings.LargeObjectHeapCompactionMode = GCLargeObjectHeapCompactionMode.CompactOnce;
        //     GC.Collect();
        // }
        //
        // private async Task SaveFile(string filename, bool suppressDebug = false)
        // {
        //
        // }
    }
}


====================================================================
FILE: ./ViewModels/EditorViewModels/LoaderDialogViewModel.cs
====================================================================

﻿using Avalonia.Controls;
using System;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;

namespace UndertaleModToolAvalonia.ViewModels.EditorsViewModels
{
    public partial class LoaderDialogViewModel : ViewModelBase
    {
        [ObservableProperty] private double value = 0;

        [ObservableProperty] private string messageTitle = string.Empty;

        [ObservableProperty] private string message = string.Empty;

        [ObservableProperty] private bool preventClose = true;
        
        [ObservableProperty] private bool isClosed = false;

        [ObservableProperty] private string statusText = "Please wait...";

        [ObservableProperty] private bool isIndeterminate = true;

        [ObservableProperty] private string savedStatusText = string.Empty;

        [ObservableProperty] private double? maximum = 100;

        [ObservableProperty] private WindowState state = WindowState.Normal;
        
        public double? ComputedMaximum => !IsIndeterminate ? maximum : null;

        partial void OnIsIndeterminateChanged(bool value)
        {
            // Notify change of ComputedMaximum whenever IsIndeterminate changes
            OnPropertyChanged(nameof(ComputedMaximum));
        }

        partial void OnMaximumChanged(double? value)
        {
            // Update IsIndeterminate based on the value of Maximum
            IsIndeterminate = !value.HasValue;

            // Notify change of ComputedMaximum whenever Maximum changes
            OnPropertyChanged(nameof(ComputedMaximum));
        }
        
        public LoaderDialogViewModel(Window perent, string title, string msg)
        {
            MessageTitle = title;
            Message = msg;
        }
        
        public async Task ReportProgress(string status)
        {
            await Task.Run(() => StatusText = status);
        }
        
        public async Task ReportProgress(double value) //update without status text changing
        {
            try
            {
                await ReportProgress(value + "/" + Maximum + (!String.IsNullOrEmpty(SavedStatusText) ? ": " + SavedStatusText : ""));
                await UpdateValue(value);
            }
            catch
            {
                //Silently fail...
            }
        }

        public async Task UpdateValue(double value)
        {
            await Task.Run(() => Value = value);
        }

        public async Task ReportProgress(string status, double value)
        {
            try
            {
                await ReportProgress(value + "/" + Maximum + (!String.IsNullOrEmpty(status) ? ": " + status : "")); //update status
                await UpdateValue(value);
            }
            catch
            {
                // Silently fail...
            }
        }

        public async Task Update(string message, string status, double progressValue, double maxValue)
        {
            if (message != null)
                await Task.Run(() => Message = message);

            if (maxValue != 0)
                await Task.Run(() => Maximum = maxValue);

            await ReportProgress(status, progressValue);
        }

        public async Task Update(string status)
        {
            await ReportProgress(status);
        }
    }
}


====================================================================
FILE: ./ViewModels/EditorViewModels/ProfileViewModel.cs
====================================================================

﻿using Avalonia.Controls;

namespace UndertaleModToolAvalonia.ViewModels.EditorsViewModels
{
    internal class ProfileViewModel : ViewModelBase
    {
        private readonly Window perent;

        public static string GameMakerStudioPath
        {
            get => Settings.Instance.GameMakerStudioPath;
            set
            {
                Settings.Instance.GameMakerStudioPath = value;
                Settings.Save();
            }
        }

        public static string GameMakerStudio2RuntimesPath
        {
            get => Settings.Instance.GameMakerStudio2RuntimesPath;
            set
            {
                Settings.Instance.GameMakerStudio2RuntimesPath = value;
                Settings.Save();
            }
        }

        public static bool AssetOrderSwappingEnabled
        {
            get => Settings.Instance.AssetOrderSwappingEnabled;
            set
            {
                Settings.Instance.AssetOrderSwappingEnabled = value;
                Settings.Save();
            }
        }

        public static bool ProfileModeEnabled
        {
            get => Settings.Instance.ProfileModeEnabled;
            set
            {
                Settings.Instance.ProfileModeEnabled = value;
                Settings.Save();
            }
        }

        public static bool UseGMLCache
        {
            get => Settings.Instance.UseGMLCache;
            set
            {
                Settings.Instance.UseGMLCache = value;
                Settings.Save();
            }
        }

        public static bool ProfileMessageShown
        {
            get => Settings.Instance.ProfileMessageShown;
            set
            {
                Settings.Instance.ProfileMessageShown = value;
                Settings.Save();
            }
        }
        public static bool TempRunMessageShow
        {
            get => Settings.Instance.TempRunMessageShow;
            set
            {
                Settings.Instance.TempRunMessageShow = value;
                Settings.Save();
            }
        }

        public static bool AutomaticFileAssociation
        {
            get => Settings.Instance.AutomaticFileAssociation;
            set
            {
                Settings.Instance.AutomaticFileAssociation = value;
                Settings.Save();
            }
        }

        public static bool DeleteOldProfileOnSave
        {
            get => Settings.Instance.DeleteOldProfileOnSave;
            set
            {
                Settings.Instance.DeleteOldProfileOnSave = value;
                Settings.Save();
            }
        }
        public static bool WarnOnClose
        {
            get => Settings.Instance.WarnOnClose;
            set
            {
                Settings.Instance.WarnOnClose = value;
                Settings.Save();
            }
        }

        public static double GlobalGridWidth
        {
            get => Settings.Instance.GlobalGridWidth;
            set
            {
                Settings.Instance.GlobalGridWidth = value;
                Settings.Save();
            }
        }

        public static bool GridWidthEnabled
        {
            get => Settings.Instance.GridWidthEnabled;
            set
            {
                Settings.Instance.GridWidthEnabled = value;
                Settings.Save();
            }
        }

        public static double GlobalGridHeight
        {
            get => Settings.Instance.GlobalGridHeight;
            set
            {
                Settings.Instance.GlobalGridHeight = value;
                Settings.Save();
            }
        }

        public static bool GridHeightEnabled
        {
            get => Settings.Instance.GridHeightEnabled;
            set
            {
                Settings.Instance.GridHeightEnabled = value;
                Settings.Save();
            }
        }

        public static double GlobalGridThickness
        {
            get => Settings.Instance.GlobalGridThickness;
            set
            {
                Settings.Instance.GlobalGridThickness = value;
                Settings.Save();
            }
        }

        public static bool GridThicknessEnabled
        {
            get => Settings.Instance.GridThicknessEnabled;
            set
            {
                Settings.Instance.GridThicknessEnabled = value;
                Settings.Save();
            }
        }

        public ProfileViewModel(Window perent)
        {
            this.perent = perent;
        }
    }
}


====================================================================
FILE: ./ViewModels/MainWindowViewModel.cs
====================================================================

using System;
using System.Collections.ObjectModel;
using System.Reflection;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using UndertaleModLib;
using UndertaleModLib.Util;
using UndertaleModToolAvalonia.ViewModels.StartPageViewModels;

namespace UndertaleModToolAvalonia.ViewModels
{
    public partial class MainWindowViewModel : ViewModelBase
    {
        [ObservableProperty] private string titleMain = string.Empty;
        
        [ObservableProperty] public UndertaleData? data = AppConstants.Data;

        [ObservableProperty] string? filePath = AppConstants.FilePath;

        // Version info
        public static string Edition = "(Git: " + GitVersion.GetGitVersion().Substring(0, 7) + ")";
        
        // On debug, build with git versions and provided release version. Otherwise, use the provided release version only.
#if DEBUG || SHOW_COMMIT_HASH
        public static string Version = Assembly.GetExecutingAssembly().GetName().Version.ToString() + (Edition != "" ? " - " + Edition : "");
#else
        public static string Version = Assembly.GetExecutingAssembly().GetName().Version.ToString();
#endif
        
        public MainWindowViewModel()
        {
            TitleMain = "UndertaleModTool by krzys_h, recreated by Joshua Vanderzee v:" + Version;
            
            Pages = new ObservableCollection<PageTemplate>()
            {
                new PageTemplate(typeof(ProjectsPageViewModel), "Projects"),
                new PageTemplate(typeof(SettingsPageViewModel), "Settings"),
            };
            OnSelectedPageChanged(Pages[0]);
        }

        [ObservableProperty] private bool isPaneOpen = false;
        
        [ObservableProperty] private ViewModelBase currentPage;

        [ObservableProperty] private PageTemplate selectedPage;

        partial void OnSelectedPageChanged(PageTemplate value)
        {
            if (value is null) return;
            var instance = Activator.CreateInstance(value.PageType);
            if (instance is null) return;
            CurrentPage = (ViewModelBase)instance;
            selectedPage = value;
        }
        
        public ObservableCollection<PageTemplate> Pages { get; }

        [RelayCommand]
        private void OnPaneOpen()
        {
            IsPaneOpen = !IsPaneOpen;
        }
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/DataItemViewModels/DataFileItemViewModel.cs
====================================================================

﻿using System;
using CommunityToolkit.Mvvm.ComponentModel;
using UndertaleModToolAvalonia.Models;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels.DataItemViewModels
{
    public partial class DataFileItemViewModel : ViewModelBase
    {
        /// <summary>
        /// Creates a new DataFileItemViewModel for the given <see cref="Models.DataFileItem"/>
        /// </summary>
        /// <param name="item">The item to load</param>
        public DataFileItemViewModel(DataFileItem item)
        {
            Name = item.Name;
            Preview = item.Preview;
        }

        [ObservableProperty] public string name = String.Empty;

        [ObservableProperty] public string preview = String.Empty;
        
        /// <summary>
        /// Gets a DataFileItem of this ViewModel
        /// </summary>
        /// <returns>The DataFileItem</returns>
        public DataFileItem GetDataFileItem()
        {
            return new DataFileItem()
            {
                Name = Name,
                Preview = Preview
            };
        }
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/DataItemViewModels/DataFileViewModel.cs
====================================================================

using Avalonia;
using CommunityToolkit.Mvvm.Input;
using CommunityToolkit.Mvvm.Messaging;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading.Tasks;
using UndertaleModToolAvalonia.Messages;
using UndertaleModToolAvalonia.Models;
using UndertaleModToolAvalonia.Utility;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels.DataItemViewModels;

public partial class DataFileViewModel : ViewModelBase
{
    public EventHandler FileLoaded { get; set; }
    
    public DataFileViewModel()
    {
        List<DataFileItem> dataFileItems = new List<DataFileItem>();
        DataFileItem OpenFile = new DataFileItem();
        OpenFile.Preview = "Open File";
        OpenFile.Name = "OpenFile";
        DataFileItem dataFile = new DataFileItem();
        dataFile.Preview = "data.wim";
        dataFile.Name = "Somepath/data.wim";
        dataFileItems.Add(OpenFile);
        dataFileItems.Add(dataFile);
        foreach (var item in dataFileItems)
            Items.Add(new DataFileItemViewModel(item));
    }
    
    [RelayCommand]
    public async Task LoadData(string filename)
    {
        // This is a test messagebox to check if ListView like functions work.
        // Since Avalonia didn't have a listview control that displayed Icons like Winows
        // I have to make it myself.
        await Application.Current.ShowMessage($"Loading data from {filename}");
        
        if (filename == "OpenFile")
        {
            var gameData = await WeakReferenceMessenger.Default.Send(new GameDataSelectionMessage());
            FileLoaded(this, null);
        }
    }

    public ObservableCollection<DataFileItemViewModel> Items { get; } = new ObservableCollection<DataFileItemViewModel>();
}

====================================================================
FILE: ./ViewModels/StartPageViewModels/GameDataViewModel.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels
{
    public class GameDataViewModel
    {
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/PageTemplate.cs
====================================================================

using System;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Media;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels;

public class PageTemplate
{
    public PageTemplate(Type pageType, string iconKey)
    {
        Label = pageType.Name.Replace("PageViewModel", "");
        PageType = pageType;

        Application.Current!.TryFindResource(iconKey, out var res);
        Icon = (StreamGeometry)res!;
    }
    
    public string Label { get; }
    public Type PageType { get; } 
    public StreamGeometry Icon { get; }
}

====================================================================
FILE: ./ViewModels/StartPageViewModels/ProjectsPageViewModel.cs
====================================================================

using System;
using System.Collections.ObjectModel;
using CommunityToolkit.Mvvm.ComponentModel;
using UndertaleModToolAvalonia.Utility;
using UndertaleModToolAvalonia.ViewModels.EditorViewModels;
using UndertaleModToolAvalonia.ViewModels.StartPageViewModels.DataItemViewModels;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels;

public partial class ProjectsPageViewModel : ViewModelBase
{
    private static ProjectsPageViewModel? _instance;
    
    private EditorViewModel _editorViewModel;
    
    public ProjectsPageViewModel()
    {
        if (_instance == null)
        {
            Console.WriteLine("Projects is initialized.");
            _instance = this;
            
            Pages = new ObservableCollection<PageTemplate>()
            {
                new PageTemplate(typeof(DataFileViewModel), "Projects"),
                new PageTemplate(typeof(EditorViewModel), "Editor"),
            };
            OnSelectedPageChanged(Pages[0]);
        }
        else
        {
            Pages = _instance.Pages;
            CurrentPage = _instance.CurrentPage;
            selectedPage = _instance.selectedPage;
            _editorViewModel = _instance._editorViewModel;
            Console.WriteLine("Already is initialized.");
            ScriptMessages.PlayInformationSound();
        }
    }
    
    [ObservableProperty] private ViewModelBase currentPage;
    
    [ObservableProperty] private PageTemplate selectedPage;
    
    public ObservableCollection<PageTemplate> Pages { get; }
    
    partial void OnSelectedPageChanged(PageTemplate value)
    {
        if (value is null) return;
        if (typeof(EditorViewModel) == value.PageType && _editorViewModel is not null)
        {
            CurrentPage = (ViewModelBase)_editorViewModel;
            selectedPage = value;
            return;
        }

        var instance = Activator.CreateInstance(value.PageType);
        if (instance is null) return;
        CurrentPage = (ViewModelBase)instance;
        selectedPage = value;
        if (typeof(EditorViewModel) == value.PageType && _editorViewModel is null)
        {
            _editorViewModel = (EditorViewModel)instance;
        }
        if (typeof(DataFileViewModel) == value.PageType)
        {
            ((DataFileViewModel)instance).FileLoaded += (s, e) => { Console.WriteLine("File Loaded"); OnSelectedPageChanged(Pages[1]); Console.WriteLine("Page Loaded"); };
        }
    }
}

====================================================================
FILE: ./ViewModels/StartPageViewModels/SettingsPageViewModel.cs
====================================================================

﻿using System.Collections.Generic;
using UndertaleModToolAvalonia.ViewModels.MainWindowViewModels.SettingsViewModels.SettingItems;

namespace UndertaleModToolAvalonia.ViewModels.StartPageViewModels
{
    class SettingsPageViewModel : ViewModelBase
    {
        public SettingsPageViewModel()
        {
        }
        
        public SettingsPageViewModel(IEnumerable<IItemViewModel> items)
        {

        }
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/SettingsViewModels/SettingItems/IItemViewModel.cs
====================================================================

﻿namespace UndertaleModToolAvalonia.ViewModels.MainWindowViewModels.SettingsViewModels.SettingItems
{
    interface IItemViewModel
    {
       
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/SettingsViewModels/SettingItems/PathSettingItemViewModel.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UndertaleModToolAvalonia.ViewModels.MainWindowViewModels.SettingsViewModels.SettingItems;

namespace UndertaleModToolAvalonia.ViewModels.SettingsViewModels.SettingItems
{
    class PathSettingItemViewModel : IItemViewModel
    {
    }
}


====================================================================
FILE: ./ViewModels/StartPageViewModels/SettingsViewModels/SettingItems/ToggleSettingItemViewModel.cs
====================================================================

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UndertaleModToolAvalonia.ViewModels.MainWindowViewModels.SettingsViewModels.SettingItems;

namespace UndertaleModToolAvalonia.ViewModels.SettingsViewModels.SettingItems
{
    class ToggleSettingItemViewModel : IItemViewModel
    {
    }
}


====================================================================
FILE: ./ViewModels/ViewModelBase.cs
====================================================================

﻿using CommunityToolkit.Mvvm.ComponentModel;

namespace UndertaleModToolAvalonia.ViewModels;

public class ViewModelBase : ObservableObject
{
}

====================================================================
FILE: ./Views/EditorViews/EditorView.axaml
====================================================================

<UserControl xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:UndertaleModToolAvalonia"
        xmlns:vm="clr-namespace:UndertaleModToolAvalonia.ViewModels.EditorViewModels"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="UndertaleModToolAvalonia.Views.EditorViews.EditorView"
        x:DataType="vm:EditorViewModel">
  <Grid>
    <DockPanel>
      <Menu DockPanel.Dock="Top">
        <MenuItem Header="_File">
          <MenuItem Header="_New" HotKey="Ctrl+N"/>
          <MenuItem Header="_Open" HotKey="Ctrl+O"/>
          <MenuItem Header="_Save" HotKey="Ctrl+S">
            <MenuItem.Styles>
              <Style Selector="MenuItem">
                <!-- <Setter Property="IsEnabled" Value="{Binding CanSave}"/> -->
              </Style>
            </MenuItem.Styles>
          </MenuItem>
          <Separator/>
          <MenuItem Header="_Temp run game" HotKey="F5">
            <!-- TODO: I think I need a custom command for that... -->
            <MenuItem.Styles>
              <Style Selector="MenuItem">
                <!-- <Setter Property="IsEnabled" Value="{Binding CanSave}"/> -->
              </Style>
            </MenuItem.Styles>
          </MenuItem>
          <MenuItem Header="Run game under _debugger" HotKey="Shift+F5">
            <MenuItem.Styles>
              <Style Selector="MenuItem">
                <!-- <Setter Property="IsEnabled" Value="{Binding CanSave}"/> -->
              </Style>
            </MenuItem.Styles>
          </MenuItem>
          <MenuItem Header="Run game with other runner" HotKey="Alt+F5">
            <MenuItem.Styles>
              <Style Selector="MenuItem">
                <!-- <Setter Property="IsEnabled" Value="{Binding CanSave}"/> -->
              </Style>
            </MenuItem.Styles>
          </MenuItem>
          <Separator/>
          <MenuItem Header="Generate o_ffset map"/>
          <Separator/>
          <MenuItem Header="S_ettings"/>
          <MenuItem Header="_Close" HotKey="Ctrl+Q"/>
        </MenuItem>
        <MenuItem Name="RootScriptItem" Header="_Scripts">
          <MenuItem Header="(...loading...)" IsEnabled="False"/>
        </MenuItem>
        <MenuItem Header="_Help">
          <MenuItem Header="_GitHub" />
          <MenuItem Header="_About" />
        </MenuItem>
      </Menu>
      <Grid DockPanel.Dock="Bottom">
        <TextBox x:Name="CommandBox" AcceptsReturn="True" Margin="0,0,35,0"/>
        <Label Content="None" HorizontalAlignment="Right" VerticalAlignment="Top" VerticalContentAlignment="Top" Name="ObjectLabel"/>
      </Grid>
      <Grid>
        <Grid.RowDefinitions>
          <RowDefinition Height="Auto"/>
          <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
          <ColumnDefinition Width="1*"/>
          <ColumnDefinition Width="Auto"/>
          <ColumnDefinition Width="3*"/>
        </Grid.ColumnDefinitions>
        <Grid Grid.Column="0" Grid.Row="0" Margin="5,5,5,0">
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
          </Grid.RowDefinitions>
          <StackPanel Grid.Row="0" Margin="0,0,0,5" Orientation="Horizontal">
            <Button Margin="0,0,2,0" Name="BackButton">
              
              <Image Name="BackButtonImage" Source="/Assets/arrow_blue.png">
                
              </Image>
            </Button>
            <Button Name="ForwardButton" >
              <Image Name="ForwardButtonImage" Margin="26,0,-26,0" RenderTransformOrigin="0.5,0.5" Source="/Assets/arrow_blue.png">
                <Image.RenderTransform>
                  <ScaleTransform ScaleX="-1" ScaleY="1"/>
                </Image.RenderTransform>
                
              </Image>
            </Button>
          </StackPanel>

          <TextBox Grid.Row="1" Name="SearchBox">
            <!-- Source - https://stackoverflow.com/a/7433840/12136394 -->
            
          </TextBox>
        </Grid>
        <TreeView Grid.Column="0" Grid.Row="1" Name="MainTree" Margin="5">
          <TreeView.Resources>
            <ContextMenu x:Key="AddMenu">
              <MenuItem Header="Add" />
            </ContextMenu>
            <ContextMenu x:Key="UndertaleResourceMenu">
              <MenuItem Header="Open in new tab" />
              <MenuItem Header="Copy name to clipboard" />
              <MenuItem Header="Delete" />
            </ContextMenu>

          </TreeView.Resources>
          <TreeViewItem Header="Data" IsExpanded="True">
            <TreeViewItem Header="General info" />
            <TreeViewItem Header="Global init" />
            <TreeViewItem Header="Game End scripts" />
            <TreeViewItem Header="Audio groups" >
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Sounds">
              <TreeViewItem.ItemTemplate>
               
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Sprites">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Name="BackgroundsItemsList" Header="Backgrounds &amp; Tile sets">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Paths" >
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Scripts" >
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Shaders" >
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Fonts">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Timelines">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Game objects">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Rooms">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Extensions">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Texture page items">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Name="CodeItemsList" Header="Code">
              
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Variables">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Functions">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Code locals">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Strings">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Embedded textures">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Embedded audio">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Texture group information">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
            <TreeViewItem Header="Embedded images">
              <TreeViewItem.ItemTemplate>
                
              </TreeViewItem.ItemTemplate>
            </TreeViewItem>
          </TreeViewItem>
        </TreeView>

        <GridSplitter Grid.Column="1" Grid.RowSpan="2" HorizontalAlignment="Center" VerticalAlignment="Stretch" ShowsPreview="True" Width="3"/>

        <Grid Grid.Column="2" Grid.RowSpan="2">
          <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
          </Grid.RowDefinitions>

          <Grid Grid.Row="0" Name="TabsGrid" UseLayoutRounding="True" Margin="0,0,0,3">
            <Grid.ColumnDefinitions>
              <ColumnDefinition Width="*"/>
              <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>
            <ScrollViewer Grid.Column="0" Name="TabScrollViewer" Height="26"
                          HorizontalScrollBarVisibility="Hidden" VerticalScrollBarVisibility="Hidden">
              <TabControl Name="TabController" Height="22" TabStripPlacement="Top">
                <TabControl.Resources>
                  <ContextMenu x:Key="TabMenu">
                    <MenuItem Header="Close" HotKey="Ctrl+W"/>
                    <MenuItem Header="Close other tabs" >
                      
                    </MenuItem>
                    <MenuItem Header="Close all tabs" HotKey="Ctrl+Shift+W"/>
                  </ContextMenu>
                </TabControl.Resources>
                <TabControl.ItemTemplate>
                  
                </TabControl.ItemTemplate>
                <TabControl.ContentTemplate>
                  
                </TabControl.ContentTemplate>
              </TabControl>
            </ScrollViewer>
            <StackPanel Grid.Column="1" Margin="5" Orientation="Horizontal">
              <Button Width="16" Height="16" >
                <Image Source="/Assets/tabs_left_button.png" Stretch="None"/>
              </Button>
              <Button Width="16" Height="16" >
                <Image Source="/Assets/tabs_right_button.png" Stretch="None"/>
              </Button>
            </StackPanel>
          </Grid>
          <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
            <ContentControl Margin="10" Name="DataEditor">
              <ContentControl.Resources>

              </ContentControl.Resources>
            </ContentControl>
          </ScrollViewer>
        </Grid>
      </Grid>
    </DockPanel>
  </Grid>
  
</UserControl>


====================================================================
FILE: ./Views/EditorViews/EditorView.axaml.cs
====================================================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace UndertaleModToolAvalonia.Views.EditorViews
{
    public partial class EditorView : UserControl
    {
        public EditorView()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/EditorViews/LoaderDialogView.axaml
====================================================================

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:UndertaleModToolAvalonia"
        xmlns:vm="clr-namespace:UndertaleModToolAvalonia.ViewModels.EditorsViewModels"
        mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="130"
        x:Class="UndertaleModToolAvalonia.Views.EditorViews.LoaderDialogView"
        Title="{Binding MessageTitle}" Height="130" Width="400" WindowStartupLocation="CenterOwner" CanResize="False"
        Topmost="True" WindowState="Maximized"
        x:DataType="vm:LoaderDialogViewModel"
		TransparencyLevelHint="AcrylicBlur"
        ExtendClientAreaToDecorationsHint="True">
	<Panel>
		<ExperimentalAcrylicBorder IsHitTestVisible="False">
			<ExperimentalAcrylicBorder.Material>
				<ExperimentalAcrylicMaterial
				    BackgroundSource="Digger"
				    TintColor="Black"
				    TintOpacity="1"
				    MaterialOpacity="0.65" />
			</ExperimentalAcrylicBorder.Material>
		</ExperimentalAcrylicBorder>
		<Grid Margin="10">
			<Grid.RowDefinitions>
				<RowDefinition Height="*"/>
				<RowDefinition Height="*"/>
				<RowDefinition Height="*"/>
			</Grid.RowDefinitions>

			<TextBlock Grid.Row="0" VerticalAlignment="Center" Text="{Binding Message}"/>
			<ProgressBar Grid.Row="1" IsIndeterminate="{Binding IsIndeterminate}" Maximum="{Binding Maximum}" Minimum="0" Value="{Binding Value}" Name="ProgressBar" Height="40" MinHeight="40"></ProgressBar>
			<TextBlock Grid.Row="2" VerticalAlignment="Center" Text="{Binding StatusText}"/>
		</Grid>
	</Panel>
</Window>


====================================================================
FILE: ./Views/EditorViews/LoaderDialogView.axaml.cs
====================================================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace UndertaleModToolAvalonia.Views.EditorViews
{
    public partial class LoaderDialogView : Window
    {
        public LoaderDialogView()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/EditorViews/ProfileView.axaml
====================================================================

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:vm="clr-namespace:UndertaleModToolAvalonia.ViewModels.EditorsViewModels"
        mc:Ignorable="d" d:DesignWidth="800"
        x:Class="UndertaleModToolAvalonia.Views.EditorViews.ProfileView"
        Title="Profiler" Width="800" SizeToContent="Height"
        x:DataType="vm:ProfileViewModel">
  <ScrollViewer VerticalScrollBarVisibility="Auto">
    <Grid Margin="10">
      <Grid.ColumnDefinitions>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition Width="*" MinWidth="60"/>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition Width="*"/>
      </Grid.ColumnDefinitions>
      <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
      </Grid.RowDefinitions>

      <TextBlock Grid.Row="1" Grid.Column="0" Margin="3" Text="Game Maker: Studio 1.4 path"/>
      <TextBox Grid.Row="1" Grid.Column="1" Margin="3" Grid.ColumnSpan="3" Text="{Binding GameMakerStudioPath}"/>

      <TextBlock Grid.Row="2" Grid.Column="0" Margin="3" Text="Game Maker: Studio 2 runtimes path"/>
      <TextBox Grid.Row="2" Grid.Column="1" Margin="3" Grid.ColumnSpan="3" Text="{Binding GameMakerStudio2RuntimesPath}"/>

      <CheckBox Grid.Row="3" Grid.Column="0" Margin="3" Content="" IsChecked="{Binding AssetOrderSwappingEnabled}"/>
      <TextBlock Grid.Row="3" Grid.Column="0" Margin="25 2 2 2" Text="Enable asset order swapping"/>
      <CheckBox Grid.Row="3" Grid.Column="2" Margin="3" Content="" IsChecked="{Binding WarnOnClose}"/>
      <TextBlock Grid.Row="3" Grid.Column="2" Margin="25 2 2 2" Text="Warn about saving before closing"/>

      <CheckBox Grid.Row="4" Grid.Column="0" Margin="3" Content="" IsChecked="{Binding AutomaticFileAssociation}"/>
      <TextBlock Grid.Row="4" Grid.Column="0" Margin="25 2 2 2" Text="Automatically associate .win files"/>
      <CheckBox Grid.Row="4" Grid.Column="2" Margin="3" Content="" IsChecked="{Binding TempRunMessageShow}"/>
      <TextBlock Grid.Row="4" Grid.Column="2" Margin="25 2 2 2" Text="Warn about temp running"/>

      <CheckBox Grid.Row="5" Grid.Column="0" Margin="3" Content="" IsChecked="{Binding UseGMLCache}"/>
      <TextBlock Grid.Row="5" Grid.Column="0" Margin="25 2 2 2" Text="Use decompiled code cache (experimental)"/>

      <Separator Grid.Row="6" Grid.ColumnSpan="4" Margin="10"/>

      <CheckBox Grid.Row="7" Grid.Column="0" Margin="3" VerticalAlignment="Center" Name="gridWidthCheckbox" Content="" IsChecked="{Binding GridWidthEnabled}"/>
      <TextBlock Grid.Row="7" Grid.Column="0" Margin="25 2 2 2" VerticalAlignment="Center" Text="Global grid width"/>
      <TextBox Grid.Row="7" Grid.Column="1" Margin="3" IsEnabled="{Binding ElementName=gridWidthCheckbox, Path=IsChecked}" Text="{Binding GlobalGridWidth}"/>

      <CheckBox Grid.Row="8" Grid.Column="0" Margin="3" VerticalAlignment="Center" Name="gridHeightCheckbox" Content="" IsChecked="{Binding GridHeightEnabled}"/>
      <TextBlock Grid.Row="8" Grid.Column="0" Margin="25 2 2 2"  VerticalAlignment="Center" Text="Global grid height"/>
      <TextBox Grid.Row="8" Grid.Column="1" Margin="3" IsEnabled="{Binding ElementName=gridHeightCheckbox, Path=IsChecked}" Text="{Binding GlobalGridHeight}"/>

      <CheckBox Grid.Row="7" Grid.Column="2" Margin="3" VerticalAlignment="Center" Name="gridThicknessCheckBox" Content="" IsChecked="{Binding GridThicknessEnabled}"/>
      <TextBlock Grid.Row="7" Grid.Column="2" Margin="25 2 2 2" VerticalAlignment="Center" Text="Global grid thickness"/>
      <TextBox Grid.Row="7" Grid.Column="3" Margin="3" IsEnabled="{Binding ElementName=gridThicknessCheckBox, Path=IsChecked}" Text="{Binding GlobalGridThickness}"/>

      <Separator Grid.Row="11" Grid.ColumnSpan="4" Margin="10"/>

      <TextBlock Grid.Row="12" Grid.Column="0" Grid.ColumnSpan="4" Margin="3" TextWrapping="Wrap" Foreground="Red" FontWeight="Bold" Text="Warning: the following options are currently experimental, as the profile system is a work in progress. Usage of the system is at your own risk, and though it is relatively stable, it may not be compatible in the future."/>

      <CheckBox Grid.Row="13" Grid.Column="0" Margin="3" VerticalAlignment="Center" Content="" IsChecked="{Binding ProfileModeEnabled}"/>
      <TextBlock Grid.Row="13" Grid.Column="0" Margin="25 2 2 2" VerticalAlignment="Center" Text="Enable profile mode"/>

      <CheckBox Grid.Row="13" Grid.Column="2" Margin="3" VerticalAlignment="Center" Content="" IsChecked="{Binding ProfileMessageShown}"/>
      <TextBlock Grid.Row="13" Grid.Column="2" Margin="25 2 2 2" VerticalAlignment="Center" Text="Profile mode message shown"/>

      <CheckBox Grid.Row="15" Grid.Column="0" Margin="3" VerticalAlignment="Center" Content="" IsChecked="{Binding DeleteOldProfileOnSave}"/>
      <TextBlock Grid.Row="15" Grid.Column="0" Margin="25 2 2 2" VerticalAlignment="Center" Text="Delete old profile on saving"/>

      <Separator Grid.Row="16" Grid.ColumnSpan="4" Margin="10"/>
      <Button Grid.Row="17" Grid.Column="0" Grid.ColumnSpan="1" Margin="5">Open application data folder</Button>
      <Button Grid.Row="17" Grid.Column="2" Grid.ColumnSpan="2" Margin="5" Name="UpdateAppButton" HorizontalAlignment="Right" Width="223">Update app to latest commit</Button>
    </Grid>
  </ScrollViewer>
</Window>


====================================================================
FILE: ./Views/EditorViews/ProfileView.axaml.cs
====================================================================

using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace UndertaleModToolAvalonia.Views.EditorViews
{
    public partial class ProfileView : Window
    {
        public ProfileView()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/MainWindow.axaml
====================================================================

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="using:UndertaleModToolAvalonia.ViewModels.StartPageViewModels"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:viewModels="clr-namespace:UndertaleModToolAvalonia.ViewModels"
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="UndertaleModToolAvalonia.Views.MainWindow"
		x:DataType="viewModels:MainWindowViewModel"
        Icon="/Assets/icon.ico" WindowStartupLocation="CenterScreen"
        TransparencyLevelHint="AcrylicBlur"
        Background="Transparent"
		ExtendClientAreaToDecorationsHint="True">
	<Window.Title>
		<MultiBinding StringFormat="{}{0} - {1} [{2}]">
			<Binding Path="TitleMain"/>
			<Binding Path="Data.GeneralInfo" FallbackValue="No game loaded"/>
			<Binding Path="FilePath"/>
		</MultiBinding>
	</Window.Title>
	<Panel>
		<ExperimentalAcrylicBorder IsHitTestVisible="False">
			<ExperimentalAcrylicBorder.Material>
				<ExperimentalAcrylicMaterial
					BackgroundSource="Digger"
					TintColor="Black"
					TintOpacity="1"
					MaterialOpacity="0.65" />
			</ExperimentalAcrylicBorder.Material>
		</ExperimentalAcrylicBorder>
		<Grid>
			<Grid.RowDefinitions>
				<RowDefinition Height="*"/>
			</Grid.RowDefinitions>
			<!-- <Border Grid.Row="0" Height="32" VerticalAlignment="Top"> -->
			<!-- 	<TextBlock Grid.Row="0" Text="{Binding Title, RelativeSource={RelativeSource FindAncestor, AncestorType=Window}}" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="7,5" /> -->
			<!-- </Border> -->

			<SplitView Grid.Row="0" Margin="0,20,0,0" IsPaneOpen="{Binding IsPaneOpen}" OpenPaneLength="300" CompactPaneLength="46" DisplayMode="CompactInline" >
				<SplitView.Pane>
					<StackPanel Orientation="Vertical" Spacing="5" HorizontalAlignment="Stretch">
						<Button Width="32" Height="32" Command="{Binding PaneOpenCommand}" Margin="7, 10">
							<PathIcon Height="11" Data="{StaticResource Navigation}" />
						</Button>
						<ListBox ItemsSource="{Binding Pages}" SelectedItem="{Binding SelectedPage}" Margin="2, 0, -100, 0" SelectedValue="1">
							<ListBox.Styles>
								<Style Selector="ListBoxItem">
									<Setter Property="Padding" Value="12, 8"></Setter>
								</Style>
							</ListBox.Styles>
							<ListBox.ItemTemplate>
								<DataTemplate x:DataType="{x:Type vm:PageTemplate}">
									<StackPanel Spacing="17" Orientation="Horizontal">
										<PathIcon Data="{Binding Icon}" Width="14"/>
										<TextBlock Text="{Binding Label}"/>
									</StackPanel>
								</DataTemplate>
							</ListBox.ItemTemplate>
						</ListBox>
					</StackPanel>
				</SplitView.Pane>
				<SplitView.Content>
					<Border CornerRadius="12">
						<TransitioningContentControl Content="{Binding CurrentPage}"/>
					</Border>
				</SplitView.Content>
			</SplitView>
		</Grid>
	</Panel>
</Window>


====================================================================
FILE: ./Views/MainWindow.axaml.cs
====================================================================

using Avalonia.Controls;
using CommunityToolkit.Mvvm.Messaging;
using FluentAvalonia.UI.Windowing;
using Microsoft.Extensions.DependencyInjection;
using UndertaleModToolAvalonia.Messages;
using UndertaleModToolAvalonia.ViewModels.StartPageViewModels;
using UndertaleModToolAvalonia.Views.EditorViews;
using UndertaleModToolAvalonia.Views.StartPageViews;

namespace UndertaleModToolAvalonia.Views
{
    public partial class MainWindow : AppWindow
    {
        public MainWindow()
        {
            InitializeComponent();
            
            TitleBar.ExtendsContentIntoTitleBar = true;
            TitleBar.TitleBarHitTestType = TitleBarHitTestType.Complex;

            if (Design.IsDesignMode)
                return;

            // This handler will now use the DI container!
            WeakReferenceMessenger.Default.Register<MainWindow, GameDataSelectionMessage>(this, static async (w, m) =>
            {
                // 1. Get the service provider from our App class
                var services = App.Current.Services;

                // 2. Ask the container for the dialog window.
                // The container is responsible for creating the window AND its ViewModel
                // and wiring them up, just as we defined in App.axaml.cs.
                var dialog = services.GetRequiredService<LoaderDialogView>();

                // 3. Show the dialog and reply with the result.
                // (Assuming your ShowDialog returns a result, otherwise just call ShowDialog(w))
                m.Reply(response: await dialog.ShowDialog<GameDataViewModel>(w));
            });
        }
    }
}


====================================================================
FILE: ./Views/StartPageViews/DataItemViews/DataFileView.axaml
====================================================================

﻿<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:vm="using:UndertaleModToolAvalonia.ViewModels.StartPageViewModels.DataItemViewModels"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="UndertaleModToolAvalonia.Views.StartPageViews.DataItemViews.DataFileView" x:Name="FileView"
             x:DataType="vm:DataFileViewModel">

  <ItemsControl ItemsSource="{Binding Items}">
    <ItemsControl.ItemsPanel>
      <ItemsPanelTemplate>
        <WrapPanel />
      </ItemsPanelTemplate>
    </ItemsControl.ItemsPanel>
    <ItemsControl.ItemTemplate>
      <DataTemplate >
        <!--  -->
        <Button BorderThickness="0" Command="{Binding #FileView.((vm:DataFileViewModel)DataContext).LoadData}" CommandParameter="{Binding Name}">
          <Button.Styles>
            <Style Selector="Button">
              <Setter Property="Background" Value="Transparent"/>
            </Style>
            <Style Selector="Button:pointerover">
              <Setter Property="Opacity" Value="0.5"/>
              <Setter Property="Background" Value="#D5BF8D"/>
            </Style>
          </Button.Styles>
          <Grid Margin="10" MinWidth="160" MinHeight="160" MaxWidth="160" MaxHeight="160">
            <Grid.RowDefinitions>
              <RowDefinition Height="2*"/>
              <RowDefinition Height="*"/>
            </Grid.RowDefinitions>
            <Grid Grid.Row="0">
              <Image x:Name="DataIcon" Margin="0,-20,0,0" Stretch="None" Source="avares://UndertaleModToolAvalonia/Assets/icon.ico" />
            </Grid>
            <TextBlock x:Name="fileName" Text="{Binding Preview}" Grid.Row="1" 
                       FontSize="18" TextWrapping="Wrap" TextAlignment="Center"
                       HorizontalAlignment="Stretch" VerticalAlignment="Stretch" LineHeight="20"
                       FontWeight="Bold"/>
          </Grid>
        </Button>
      </DataTemplate>
    </ItemsControl.ItemTemplate>
  </ItemsControl>
</UserControl>


====================================================================
FILE: ./Views/StartPageViews/DataItemViews/DataFileView.axaml.cs
====================================================================

﻿using Avalonia.Controls;

namespace UndertaleModToolAvalonia.Views.StartPageViews.DataItemViews
{
    public partial class DataFileView : UserControl
    {
        public DataFileView()
        {
            this.InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/StartPageViews/ProjectsPageView.axaml
====================================================================

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:views="using:UndertaleModToolAvalonia.Views.StartPageViews.DataItemViews"
             xmlns:vm="using:UndertaleModToolAvalonia.ViewModels.StartPageViewModels"
             xmlns:ui="using:FluentAvalonia.UI.Controls"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="UndertaleModToolAvalonia.Views.StartPageViews.ProjectsPageView"
             x:DataType="vm:ProjectsPageViewModel">
  <Grid>
    <Grid.RowDefinitions>
      <RowDefinition Height="*"/>
    </Grid.RowDefinitions>
    <Border Grid.Row="0" Margin="10" BorderBrush="DarkGray" BorderThickness="2">
      <ScrollViewer VerticalScrollBarVisibility="Visible" HorizontalScrollBarVisibility="Disabled" AllowAutoHide="False">
        <Border CornerRadius="12">
          <TransitioningContentControl Content="{Binding CurrentPage}" >
            <TransitioningContentControl.PageTransition>
              <PageSlide Orientation="Horizontal" Duration="0:00:00.500" />
            </TransitioningContentControl.PageTransition>
          </TransitioningContentControl>
          <!--
          <views:DataFileView DataContext="{Binding FileViewModel}" Background="Transparent"/>
        -->
        </Border>
      </ScrollViewer>
    </Border>
  </Grid>
</UserControl>


====================================================================
FILE: ./Views/StartPageViews/ProjectsPageView.axaml.cs
====================================================================

using Avalonia.Controls;
using CommunityToolkit.Mvvm.Messaging;
using UndertaleModToolAvalonia.Messages;
using UndertaleModToolAvalonia.ViewModels.EditorsViewModels;
using UndertaleModToolAvalonia.Views.EditorViews;

namespace UndertaleModToolAvalonia.Views.StartPageViews
{
    public partial class ProjectsPageView : UserControl
    {
        public ProjectsPageView()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/StartPageViews/SettingItem/PathSettingItem.axaml
====================================================================

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="50"
             x:Class="UndertaleModToolAvalonia.Views.StartPageViews.SettingItem.PathSettingItem"
             Height="50">
  <Grid>
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="*"/>
      <ColumnDefinition Width="95"/>
    </Grid.ColumnDefinitions>
    <DockPanel Margin="40,0,30,0" >
      <TextBlock Text="Path" FontSize="18" VerticalAlignment="Center"
                 Margin="0,0,10,0" FontWeight="Bold" DockPanel.Dock="Left"/>
      <Border VerticalAlignment="Center" BorderThickness="1" HorizontalAlignment="Right"
              BorderBrush="Black" Background="White" DockPanel.Dock="Right">
        <TextBlock Text="C:\something\stuff\otherstuff" Margin="8,4,8,4"
                   FontSize="18" TextTrimming="CharacterEllipsis"/>
      </Border>
    </DockPanel>
    <Button Content="Browse" Margin="0,0,0,0" Grid.Column="1"/>
  </Grid>
</UserControl>


====================================================================
FILE: ./Views/StartPageViews/SettingItem/PathSettingItem.axaml.cs
====================================================================

using Avalonia.Controls;

namespace UndertaleModToolAvalonia.Views.StartPageViews.SettingItem
{
    public partial class PathSettingItem : UserControl
    {
        public PathSettingItem()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/StartPageViews/SettingItem/ToggleSettingItem.axaml
====================================================================

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="400" d:DesignHeight="50"
             x:Class="UndertaleModToolAvalonia.Views.StartPageViews.SettingItem.ToggleSettingItem"
             Height="50">
  <DockPanel VerticalAlignment="Stretch">
    <TextBlock Text="Setting" VerticalAlignment="Center" FontSize="18" Margin="40,0,0,0" FontWeight="Bold"/>
    <ToggleSwitch HorizontalAlignment="Right" OnContent="" OffContent="" Margin="0,0,30,0">
    </ToggleSwitch>
  </DockPanel>
</UserControl>


====================================================================
FILE: ./Views/StartPageViews/SettingItem/ToggleSettingItem.axaml.cs
====================================================================

using Avalonia.Controls;

namespace UndertaleModToolAvalonia.Views.StartPageViews.SettingItem
{
    public partial class ToggleSettingItem : UserControl
    {
        public ToggleSettingItem()
        {
            InitializeComponent();
        }
    }
}


====================================================================
FILE: ./Views/StartPageViews/SettingsPageView.axaml
====================================================================

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:SettingItems="clr-namespace:UndertaleModToolAvalonia.Views.StartPageViews.SettingItem"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
             x:Class="UndertaleModToolAvalonia.Views.StartPageViews.SettingsPageView">
  <StackPanel>
    <SettingItems:ToggleSettingItem />
    <SettingItems:ToggleSettingItem />
    <SettingItems:ToggleSettingItem />
    <SettingItems:PathSettingItem />
    <SettingItems:PathSettingItem />
    <SettingItems:ToggleSettingItem />
    <SettingItems:ToggleSettingItem />
    <SettingItems:PathSettingItem />
    <SettingItems:ToggleSettingItem />
  </StackPanel>
</UserControl>


====================================================================
FILE: ./Views/StartPageViews/SettingsPageView.axaml.cs
====================================================================

using Avalonia.Controls;

namespace UndertaleModToolAvalonia.Views.StartPageViews
{
    public partial class SettingsPageView : UserControl
    {
        public SettingsPageView()
        {
            InitializeComponent();
        }
    }
}


